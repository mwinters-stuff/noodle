// Code generated by counterfeiter. DO NOT EDIT.
package databasefakes

import (
	"sync"

	"github.com/jackc/pgx/v5/pgxpool"
	"github.com/mwinters-stuff/noodle/noodle/database"
)

type FakeDatabase struct {
	CheckUpgradeStub        func() (bool, error)
	checkUpgradeMutex       sync.RWMutex
	checkUpgradeArgsForCall []struct {
	}
	checkUpgradeReturns struct {
		result1 bool
		result2 error
	}
	checkUpgradeReturnsOnCall map[int]struct {
		result1 bool
		result2 error
	}
	CloseStub        func()
	closeMutex       sync.RWMutex
	closeArgsForCall []struct {
	}
	ConnectStub        func() error
	connectMutex       sync.RWMutex
	connectArgsForCall []struct {
	}
	connectReturns struct {
		result1 error
	}
	connectReturnsOnCall map[int]struct {
		result1 error
	}
	CreateStub        func() error
	createMutex       sync.RWMutex
	createArgsForCall []struct {
	}
	createReturns struct {
		result1 error
	}
	createReturnsOnCall map[int]struct {
		result1 error
	}
	DropStub        func() error
	dropMutex       sync.RWMutex
	dropArgsForCall []struct {
	}
	dropReturns struct {
		result1 error
	}
	dropReturnsOnCall map[int]struct {
		result1 error
	}
	GetVersionStub        func() (int, error)
	getVersionMutex       sync.RWMutex
	getVersionArgsForCall []struct {
	}
	getVersionReturns struct {
		result1 int
		result2 error
	}
	getVersionReturnsOnCall map[int]struct {
		result1 int
		result2 error
	}
	PoolStub        func() *pgxpool.Pool
	poolMutex       sync.RWMutex
	poolArgsForCall []struct {
	}
	poolReturns struct {
		result1 *pgxpool.Pool
	}
	poolReturnsOnCall map[int]struct {
		result1 *pgxpool.Pool
	}
	UpgradeStub        func(int) error
	upgradeMutex       sync.RWMutex
	upgradeArgsForCall []struct {
		arg1 int
	}
	upgradeReturns struct {
		result1 error
	}
	upgradeReturnsOnCall map[int]struct {
		result1 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeDatabase) CheckUpgrade() (bool, error) {
	fake.checkUpgradeMutex.Lock()
	ret, specificReturn := fake.checkUpgradeReturnsOnCall[len(fake.checkUpgradeArgsForCall)]
	fake.checkUpgradeArgsForCall = append(fake.checkUpgradeArgsForCall, struct {
	}{})
	stub := fake.CheckUpgradeStub
	fakeReturns := fake.checkUpgradeReturns
	fake.recordInvocation("CheckUpgrade", []interface{}{})
	fake.checkUpgradeMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDatabase) CheckUpgradeCallCount() int {
	fake.checkUpgradeMutex.RLock()
	defer fake.checkUpgradeMutex.RUnlock()
	return len(fake.checkUpgradeArgsForCall)
}

func (fake *FakeDatabase) CheckUpgradeCalls(stub func() (bool, error)) {
	fake.checkUpgradeMutex.Lock()
	defer fake.checkUpgradeMutex.Unlock()
	fake.CheckUpgradeStub = stub
}

func (fake *FakeDatabase) CheckUpgradeReturns(result1 bool, result2 error) {
	fake.checkUpgradeMutex.Lock()
	defer fake.checkUpgradeMutex.Unlock()
	fake.CheckUpgradeStub = nil
	fake.checkUpgradeReturns = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeDatabase) CheckUpgradeReturnsOnCall(i int, result1 bool, result2 error) {
	fake.checkUpgradeMutex.Lock()
	defer fake.checkUpgradeMutex.Unlock()
	fake.CheckUpgradeStub = nil
	if fake.checkUpgradeReturnsOnCall == nil {
		fake.checkUpgradeReturnsOnCall = make(map[int]struct {
			result1 bool
			result2 error
		})
	}
	fake.checkUpgradeReturnsOnCall[i] = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeDatabase) Close() {
	fake.closeMutex.Lock()
	fake.closeArgsForCall = append(fake.closeArgsForCall, struct {
	}{})
	stub := fake.CloseStub
	fake.recordInvocation("Close", []interface{}{})
	fake.closeMutex.Unlock()
	if stub != nil {
		fake.CloseStub()
	}
}

func (fake *FakeDatabase) CloseCallCount() int {
	fake.closeMutex.RLock()
	defer fake.closeMutex.RUnlock()
	return len(fake.closeArgsForCall)
}

func (fake *FakeDatabase) CloseCalls(stub func()) {
	fake.closeMutex.Lock()
	defer fake.closeMutex.Unlock()
	fake.CloseStub = stub
}

func (fake *FakeDatabase) Connect() error {
	fake.connectMutex.Lock()
	ret, specificReturn := fake.connectReturnsOnCall[len(fake.connectArgsForCall)]
	fake.connectArgsForCall = append(fake.connectArgsForCall, struct {
	}{})
	stub := fake.ConnectStub
	fakeReturns := fake.connectReturns
	fake.recordInvocation("Connect", []interface{}{})
	fake.connectMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeDatabase) ConnectCallCount() int {
	fake.connectMutex.RLock()
	defer fake.connectMutex.RUnlock()
	return len(fake.connectArgsForCall)
}

func (fake *FakeDatabase) ConnectCalls(stub func() error) {
	fake.connectMutex.Lock()
	defer fake.connectMutex.Unlock()
	fake.ConnectStub = stub
}

func (fake *FakeDatabase) ConnectReturns(result1 error) {
	fake.connectMutex.Lock()
	defer fake.connectMutex.Unlock()
	fake.ConnectStub = nil
	fake.connectReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeDatabase) ConnectReturnsOnCall(i int, result1 error) {
	fake.connectMutex.Lock()
	defer fake.connectMutex.Unlock()
	fake.ConnectStub = nil
	if fake.connectReturnsOnCall == nil {
		fake.connectReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.connectReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeDatabase) Create() error {
	fake.createMutex.Lock()
	ret, specificReturn := fake.createReturnsOnCall[len(fake.createArgsForCall)]
	fake.createArgsForCall = append(fake.createArgsForCall, struct {
	}{})
	stub := fake.CreateStub
	fakeReturns := fake.createReturns
	fake.recordInvocation("Create", []interface{}{})
	fake.createMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeDatabase) CreateCallCount() int {
	fake.createMutex.RLock()
	defer fake.createMutex.RUnlock()
	return len(fake.createArgsForCall)
}

func (fake *FakeDatabase) CreateCalls(stub func() error) {
	fake.createMutex.Lock()
	defer fake.createMutex.Unlock()
	fake.CreateStub = stub
}

func (fake *FakeDatabase) CreateReturns(result1 error) {
	fake.createMutex.Lock()
	defer fake.createMutex.Unlock()
	fake.CreateStub = nil
	fake.createReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeDatabase) CreateReturnsOnCall(i int, result1 error) {
	fake.createMutex.Lock()
	defer fake.createMutex.Unlock()
	fake.CreateStub = nil
	if fake.createReturnsOnCall == nil {
		fake.createReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.createReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeDatabase) Drop() error {
	fake.dropMutex.Lock()
	ret, specificReturn := fake.dropReturnsOnCall[len(fake.dropArgsForCall)]
	fake.dropArgsForCall = append(fake.dropArgsForCall, struct {
	}{})
	stub := fake.DropStub
	fakeReturns := fake.dropReturns
	fake.recordInvocation("Drop", []interface{}{})
	fake.dropMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeDatabase) DropCallCount() int {
	fake.dropMutex.RLock()
	defer fake.dropMutex.RUnlock()
	return len(fake.dropArgsForCall)
}

func (fake *FakeDatabase) DropCalls(stub func() error) {
	fake.dropMutex.Lock()
	defer fake.dropMutex.Unlock()
	fake.DropStub = stub
}

func (fake *FakeDatabase) DropReturns(result1 error) {
	fake.dropMutex.Lock()
	defer fake.dropMutex.Unlock()
	fake.DropStub = nil
	fake.dropReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeDatabase) DropReturnsOnCall(i int, result1 error) {
	fake.dropMutex.Lock()
	defer fake.dropMutex.Unlock()
	fake.DropStub = nil
	if fake.dropReturnsOnCall == nil {
		fake.dropReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.dropReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeDatabase) GetVersion() (int, error) {
	fake.getVersionMutex.Lock()
	ret, specificReturn := fake.getVersionReturnsOnCall[len(fake.getVersionArgsForCall)]
	fake.getVersionArgsForCall = append(fake.getVersionArgsForCall, struct {
	}{})
	stub := fake.GetVersionStub
	fakeReturns := fake.getVersionReturns
	fake.recordInvocation("GetVersion", []interface{}{})
	fake.getVersionMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDatabase) GetVersionCallCount() int {
	fake.getVersionMutex.RLock()
	defer fake.getVersionMutex.RUnlock()
	return len(fake.getVersionArgsForCall)
}

func (fake *FakeDatabase) GetVersionCalls(stub func() (int, error)) {
	fake.getVersionMutex.Lock()
	defer fake.getVersionMutex.Unlock()
	fake.GetVersionStub = stub
}

func (fake *FakeDatabase) GetVersionReturns(result1 int, result2 error) {
	fake.getVersionMutex.Lock()
	defer fake.getVersionMutex.Unlock()
	fake.GetVersionStub = nil
	fake.getVersionReturns = struct {
		result1 int
		result2 error
	}{result1, result2}
}

func (fake *FakeDatabase) GetVersionReturnsOnCall(i int, result1 int, result2 error) {
	fake.getVersionMutex.Lock()
	defer fake.getVersionMutex.Unlock()
	fake.GetVersionStub = nil
	if fake.getVersionReturnsOnCall == nil {
		fake.getVersionReturnsOnCall = make(map[int]struct {
			result1 int
			result2 error
		})
	}
	fake.getVersionReturnsOnCall[i] = struct {
		result1 int
		result2 error
	}{result1, result2}
}

func (fake *FakeDatabase) Pool() *pgxpool.Pool {
	fake.poolMutex.Lock()
	ret, specificReturn := fake.poolReturnsOnCall[len(fake.poolArgsForCall)]
	fake.poolArgsForCall = append(fake.poolArgsForCall, struct {
	}{})
	stub := fake.PoolStub
	fakeReturns := fake.poolReturns
	fake.recordInvocation("Pool", []interface{}{})
	fake.poolMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeDatabase) PoolCallCount() int {
	fake.poolMutex.RLock()
	defer fake.poolMutex.RUnlock()
	return len(fake.poolArgsForCall)
}

func (fake *FakeDatabase) PoolCalls(stub func() *pgxpool.Pool) {
	fake.poolMutex.Lock()
	defer fake.poolMutex.Unlock()
	fake.PoolStub = stub
}

func (fake *FakeDatabase) PoolReturns(result1 *pgxpool.Pool) {
	fake.poolMutex.Lock()
	defer fake.poolMutex.Unlock()
	fake.PoolStub = nil
	fake.poolReturns = struct {
		result1 *pgxpool.Pool
	}{result1}
}

func (fake *FakeDatabase) PoolReturnsOnCall(i int, result1 *pgxpool.Pool) {
	fake.poolMutex.Lock()
	defer fake.poolMutex.Unlock()
	fake.PoolStub = nil
	if fake.poolReturnsOnCall == nil {
		fake.poolReturnsOnCall = make(map[int]struct {
			result1 *pgxpool.Pool
		})
	}
	fake.poolReturnsOnCall[i] = struct {
		result1 *pgxpool.Pool
	}{result1}
}

func (fake *FakeDatabase) Upgrade(arg1 int) error {
	fake.upgradeMutex.Lock()
	ret, specificReturn := fake.upgradeReturnsOnCall[len(fake.upgradeArgsForCall)]
	fake.upgradeArgsForCall = append(fake.upgradeArgsForCall, struct {
		arg1 int
	}{arg1})
	stub := fake.UpgradeStub
	fakeReturns := fake.upgradeReturns
	fake.recordInvocation("Upgrade", []interface{}{arg1})
	fake.upgradeMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeDatabase) UpgradeCallCount() int {
	fake.upgradeMutex.RLock()
	defer fake.upgradeMutex.RUnlock()
	return len(fake.upgradeArgsForCall)
}

func (fake *FakeDatabase) UpgradeCalls(stub func(int) error) {
	fake.upgradeMutex.Lock()
	defer fake.upgradeMutex.Unlock()
	fake.UpgradeStub = stub
}

func (fake *FakeDatabase) UpgradeArgsForCall(i int) int {
	fake.upgradeMutex.RLock()
	defer fake.upgradeMutex.RUnlock()
	argsForCall := fake.upgradeArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeDatabase) UpgradeReturns(result1 error) {
	fake.upgradeMutex.Lock()
	defer fake.upgradeMutex.Unlock()
	fake.UpgradeStub = nil
	fake.upgradeReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeDatabase) UpgradeReturnsOnCall(i int, result1 error) {
	fake.upgradeMutex.Lock()
	defer fake.upgradeMutex.Unlock()
	fake.UpgradeStub = nil
	if fake.upgradeReturnsOnCall == nil {
		fake.upgradeReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.upgradeReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeDatabase) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.checkUpgradeMutex.RLock()
	defer fake.checkUpgradeMutex.RUnlock()
	fake.closeMutex.RLock()
	defer fake.closeMutex.RUnlock()
	fake.connectMutex.RLock()
	defer fake.connectMutex.RUnlock()
	fake.createMutex.RLock()
	defer fake.createMutex.RUnlock()
	fake.dropMutex.RLock()
	defer fake.dropMutex.RUnlock()
	fake.getVersionMutex.RLock()
	defer fake.getVersionMutex.RUnlock()
	fake.poolMutex.RLock()
	defer fake.poolMutex.RUnlock()
	fake.upgradeMutex.RLock()
	defer fake.upgradeMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeDatabase) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ database.Database = new(FakeDatabase)
