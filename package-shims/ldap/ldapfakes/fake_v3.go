// Code generated by counterfeiter. DO NOT EDIT.
package ldapfakes

import (
	"crypto/tls"
	"log"
	"net"
	"sync"

	ber "github.com/go-asn1-ber/asn1-ber"
	ldap "github.com/go-ldap/ldap/v3"
	v3shim "github.com/mwinters-stuff/noodle/package-shims/ldap"
)

type FakeV3 struct {
	CompileFilterStub        func(string) (*ber.Packet, error)
	compileFilterMutex       sync.RWMutex
	compileFilterArgsForCall []struct {
		arg1 string
	}
	compileFilterReturns struct {
		result1 *ber.Packet
		result2 error
	}
	compileFilterReturnsOnCall map[int]struct {
		result1 *ber.Packet
		result2 error
	}
	DebugBinaryFileStub        func(string) error
	debugBinaryFileMutex       sync.RWMutex
	debugBinaryFileArgsForCall []struct {
		arg1 string
	}
	debugBinaryFileReturns struct {
		result1 error
	}
	debugBinaryFileReturnsOnCall map[int]struct {
		result1 error
	}
	DecodeControlStub        func(*ber.Packet) (ldap.Control, error)
	decodeControlMutex       sync.RWMutex
	decodeControlArgsForCall []struct {
		arg1 *ber.Packet
	}
	decodeControlReturns struct {
		result1 ldap.Control
		result2 error
	}
	decodeControlReturnsOnCall map[int]struct {
		result1 ldap.Control
		result2 error
	}
	DecompileFilterStub        func(*ber.Packet) (string, error)
	decompileFilterMutex       sync.RWMutex
	decompileFilterArgsForCall []struct {
		arg1 *ber.Packet
	}
	decompileFilterReturns struct {
		result1 string
		result2 error
	}
	decompileFilterReturnsOnCall map[int]struct {
		result1 string
		result2 error
	}
	DialStub        func(string, string) (*ldap.Conn, error)
	dialMutex       sync.RWMutex
	dialArgsForCall []struct {
		arg1 string
		arg2 string
	}
	dialReturns struct {
		result1 *ldap.Conn
		result2 error
	}
	dialReturnsOnCall map[int]struct {
		result1 *ldap.Conn
		result2 error
	}
	DialTLSStub        func(string, string, *tls.Config) (*ldap.Conn, error)
	dialTLSMutex       sync.RWMutex
	dialTLSArgsForCall []struct {
		arg1 string
		arg2 string
		arg3 *tls.Config
	}
	dialTLSReturns struct {
		result1 *ldap.Conn
		result2 error
	}
	dialTLSReturnsOnCall map[int]struct {
		result1 *ldap.Conn
		result2 error
	}
	DialURLStub        func(string, ...ldap.DialOpt) (*ldap.Conn, error)
	dialURLMutex       sync.RWMutex
	dialURLArgsForCall []struct {
		arg1 string
		arg2 []ldap.DialOpt
	}
	dialURLReturns struct {
		result1 *ldap.Conn
		result2 error
	}
	dialURLReturnsOnCall map[int]struct {
		result1 *ldap.Conn
		result2 error
	}
	DialWithDialerStub        func(*net.Dialer) ldap.DialOpt
	dialWithDialerMutex       sync.RWMutex
	dialWithDialerArgsForCall []struct {
		arg1 *net.Dialer
	}
	dialWithDialerReturns struct {
		result1 ldap.DialOpt
	}
	dialWithDialerReturnsOnCall map[int]struct {
		result1 ldap.DialOpt
	}
	DialWithTLSConfigStub        func(*tls.Config) ldap.DialOpt
	dialWithTLSConfigMutex       sync.RWMutex
	dialWithTLSConfigArgsForCall []struct {
		arg1 *tls.Config
	}
	dialWithTLSConfigReturns struct {
		result1 ldap.DialOpt
	}
	dialWithTLSConfigReturnsOnCall map[int]struct {
		result1 ldap.DialOpt
	}
	DialWithTLSDialerStub        func(*tls.Config, *net.Dialer) ldap.DialOpt
	dialWithTLSDialerMutex       sync.RWMutex
	dialWithTLSDialerArgsForCall []struct {
		arg1 *tls.Config
		arg2 *net.Dialer
	}
	dialWithTLSDialerReturns struct {
		result1 ldap.DialOpt
	}
	dialWithTLSDialerReturnsOnCall map[int]struct {
		result1 ldap.DialOpt
	}
	EscapeFilterStub        func(string) string
	escapeFilterMutex       sync.RWMutex
	escapeFilterArgsForCall []struct {
		arg1 string
	}
	escapeFilterReturns struct {
		result1 string
	}
	escapeFilterReturnsOnCall map[int]struct {
		result1 string
	}
	FindControlStub        func([]ldap.Control, string) ldap.Control
	findControlMutex       sync.RWMutex
	findControlArgsForCall []struct {
		arg1 []ldap.Control
		arg2 string
	}
	findControlReturns struct {
		result1 ldap.Control
	}
	findControlReturnsOnCall map[int]struct {
		result1 ldap.Control
	}
	GetLDAPErrorStub        func(*ber.Packet) error
	getLDAPErrorMutex       sync.RWMutex
	getLDAPErrorArgsForCall []struct {
		arg1 *ber.Packet
	}
	getLDAPErrorReturns struct {
		result1 error
	}
	getLDAPErrorReturnsOnCall map[int]struct {
		result1 error
	}
	IsErrorAnyOfStub        func(error, ...uint16) bool
	isErrorAnyOfMutex       sync.RWMutex
	isErrorAnyOfArgsForCall []struct {
		arg1 error
		arg2 []uint16
	}
	isErrorAnyOfReturns struct {
		result1 bool
	}
	isErrorAnyOfReturnsOnCall map[int]struct {
		result1 bool
	}
	IsErrorWithCodeStub        func(error, uint16) bool
	isErrorWithCodeMutex       sync.RWMutex
	isErrorWithCodeArgsForCall []struct {
		arg1 error
		arg2 uint16
	}
	isErrorWithCodeReturns struct {
		result1 bool
	}
	isErrorWithCodeReturnsOnCall map[int]struct {
		result1 bool
	}
	LoggerStub        func(*log.Logger)
	loggerMutex       sync.RWMutex
	loggerArgsForCall []struct {
		arg1 *log.Logger
	}
	NewAddRequestStub        func(string, []ldap.Control) *ldap.AddRequest
	newAddRequestMutex       sync.RWMutex
	newAddRequestArgsForCall []struct {
		arg1 string
		arg2 []ldap.Control
	}
	newAddRequestReturns struct {
		result1 *ldap.AddRequest
	}
	newAddRequestReturnsOnCall map[int]struct {
		result1 *ldap.AddRequest
	}
	NewConnStub        func(net.Conn, bool) *ldap.Conn
	newConnMutex       sync.RWMutex
	newConnArgsForCall []struct {
		arg1 net.Conn
		arg2 bool
	}
	newConnReturns struct {
		result1 *ldap.Conn
	}
	newConnReturnsOnCall map[int]struct {
		result1 *ldap.Conn
	}
	NewControlBeheraPasswordPolicyStub        func() *ldap.ControlBeheraPasswordPolicy
	newControlBeheraPasswordPolicyMutex       sync.RWMutex
	newControlBeheraPasswordPolicyArgsForCall []struct {
	}
	newControlBeheraPasswordPolicyReturns struct {
		result1 *ldap.ControlBeheraPasswordPolicy
	}
	newControlBeheraPasswordPolicyReturnsOnCall map[int]struct {
		result1 *ldap.ControlBeheraPasswordPolicy
	}
	NewControlManageDsaITStub        func(bool) *ldap.ControlManageDsaIT
	newControlManageDsaITMutex       sync.RWMutex
	newControlManageDsaITArgsForCall []struct {
		arg1 bool
	}
	newControlManageDsaITReturns struct {
		result1 *ldap.ControlManageDsaIT
	}
	newControlManageDsaITReturnsOnCall map[int]struct {
		result1 *ldap.ControlManageDsaIT
	}
	NewControlMicrosoftNotificationStub        func() *ldap.ControlMicrosoftNotification
	newControlMicrosoftNotificationMutex       sync.RWMutex
	newControlMicrosoftNotificationArgsForCall []struct {
	}
	newControlMicrosoftNotificationReturns struct {
		result1 *ldap.ControlMicrosoftNotification
	}
	newControlMicrosoftNotificationReturnsOnCall map[int]struct {
		result1 *ldap.ControlMicrosoftNotification
	}
	NewControlMicrosoftServerLinkTTLStub        func() *ldap.ControlMicrosoftServerLinkTTL
	newControlMicrosoftServerLinkTTLMutex       sync.RWMutex
	newControlMicrosoftServerLinkTTLArgsForCall []struct {
	}
	newControlMicrosoftServerLinkTTLReturns struct {
		result1 *ldap.ControlMicrosoftServerLinkTTL
	}
	newControlMicrosoftServerLinkTTLReturnsOnCall map[int]struct {
		result1 *ldap.ControlMicrosoftServerLinkTTL
	}
	NewControlMicrosoftShowDeletedStub        func() *ldap.ControlMicrosoftShowDeleted
	newControlMicrosoftShowDeletedMutex       sync.RWMutex
	newControlMicrosoftShowDeletedArgsForCall []struct {
	}
	newControlMicrosoftShowDeletedReturns struct {
		result1 *ldap.ControlMicrosoftShowDeleted
	}
	newControlMicrosoftShowDeletedReturnsOnCall map[int]struct {
		result1 *ldap.ControlMicrosoftShowDeleted
	}
	NewControlPagingStub        func(uint32) *ldap.ControlPaging
	newControlPagingMutex       sync.RWMutex
	newControlPagingArgsForCall []struct {
		arg1 uint32
	}
	newControlPagingReturns struct {
		result1 *ldap.ControlPaging
	}
	newControlPagingReturnsOnCall map[int]struct {
		result1 *ldap.ControlPaging
	}
	NewControlStringStub        func(string, bool, string) *ldap.ControlString
	newControlStringMutex       sync.RWMutex
	newControlStringArgsForCall []struct {
		arg1 string
		arg2 bool
		arg3 string
	}
	newControlStringReturns struct {
		result1 *ldap.ControlString
	}
	newControlStringReturnsOnCall map[int]struct {
		result1 *ldap.ControlString
	}
	NewControlSubtreeDeleteStub        func() *ldap.ControlSubtreeDelete
	newControlSubtreeDeleteMutex       sync.RWMutex
	newControlSubtreeDeleteArgsForCall []struct {
	}
	newControlSubtreeDeleteReturns struct {
		result1 *ldap.ControlSubtreeDelete
	}
	newControlSubtreeDeleteReturnsOnCall map[int]struct {
		result1 *ldap.ControlSubtreeDelete
	}
	NewDelRequestStub        func(string, []ldap.Control) *ldap.DelRequest
	newDelRequestMutex       sync.RWMutex
	newDelRequestArgsForCall []struct {
		arg1 string
		arg2 []ldap.Control
	}
	newDelRequestReturns struct {
		result1 *ldap.DelRequest
	}
	newDelRequestReturnsOnCall map[int]struct {
		result1 *ldap.DelRequest
	}
	NewEntryStub        func(string, map[string][]string) *ldap.Entry
	newEntryMutex       sync.RWMutex
	newEntryArgsForCall []struct {
		arg1 string
		arg2 map[string][]string
	}
	newEntryReturns struct {
		result1 *ldap.Entry
	}
	newEntryReturnsOnCall map[int]struct {
		result1 *ldap.Entry
	}
	NewEntryAttributeStub        func(string, []string) *ldap.EntryAttribute
	newEntryAttributeMutex       sync.RWMutex
	newEntryAttributeArgsForCall []struct {
		arg1 string
		arg2 []string
	}
	newEntryAttributeReturns struct {
		result1 *ldap.EntryAttribute
	}
	newEntryAttributeReturnsOnCall map[int]struct {
		result1 *ldap.EntryAttribute
	}
	NewErrorStub        func(uint16, error) error
	newErrorMutex       sync.RWMutex
	newErrorArgsForCall []struct {
		arg1 uint16
		arg2 error
	}
	newErrorReturns struct {
		result1 error
	}
	newErrorReturnsOnCall map[int]struct {
		result1 error
	}
	NewModifyDNRequestStub        func(string, string, bool, string) *ldap.ModifyDNRequest
	newModifyDNRequestMutex       sync.RWMutex
	newModifyDNRequestArgsForCall []struct {
		arg1 string
		arg2 string
		arg3 bool
		arg4 string
	}
	newModifyDNRequestReturns struct {
		result1 *ldap.ModifyDNRequest
	}
	newModifyDNRequestReturnsOnCall map[int]struct {
		result1 *ldap.ModifyDNRequest
	}
	NewModifyDNWithControlsRequestStub        func(string, string, bool, string, []ldap.Control) *ldap.ModifyDNRequest
	newModifyDNWithControlsRequestMutex       sync.RWMutex
	newModifyDNWithControlsRequestArgsForCall []struct {
		arg1 string
		arg2 string
		arg3 bool
		arg4 string
		arg5 []ldap.Control
	}
	newModifyDNWithControlsRequestReturns struct {
		result1 *ldap.ModifyDNRequest
	}
	newModifyDNWithControlsRequestReturnsOnCall map[int]struct {
		result1 *ldap.ModifyDNRequest
	}
	NewModifyRequestStub        func(string, []ldap.Control) *ldap.ModifyRequest
	newModifyRequestMutex       sync.RWMutex
	newModifyRequestArgsForCall []struct {
		arg1 string
		arg2 []ldap.Control
	}
	newModifyRequestReturns struct {
		result1 *ldap.ModifyRequest
	}
	newModifyRequestReturnsOnCall map[int]struct {
		result1 *ldap.ModifyRequest
	}
	NewPasswordModifyRequestStub        func(string, string, string) *ldap.PasswordModifyRequest
	newPasswordModifyRequestMutex       sync.RWMutex
	newPasswordModifyRequestArgsForCall []struct {
		arg1 string
		arg2 string
		arg3 string
	}
	newPasswordModifyRequestReturns struct {
		result1 *ldap.PasswordModifyRequest
	}
	newPasswordModifyRequestReturnsOnCall map[int]struct {
		result1 *ldap.PasswordModifyRequest
	}
	NewSearchRequestStub        func(string, int, int, int, int, bool, string, []string, []ldap.Control) *ldap.SearchRequest
	newSearchRequestMutex       sync.RWMutex
	newSearchRequestArgsForCall []struct {
		arg1 string
		arg2 int
		arg3 int
		arg4 int
		arg5 int
		arg6 bool
		arg7 string
		arg8 []string
		arg9 []ldap.Control
	}
	newSearchRequestReturns struct {
		result1 *ldap.SearchRequest
	}
	newSearchRequestReturnsOnCall map[int]struct {
		result1 *ldap.SearchRequest
	}
	NewSimpleBindRequestStub        func(string, string, []ldap.Control) *ldap.SimpleBindRequest
	newSimpleBindRequestMutex       sync.RWMutex
	newSimpleBindRequestArgsForCall []struct {
		arg1 string
		arg2 string
		arg3 []ldap.Control
	}
	newSimpleBindRequestReturns struct {
		result1 *ldap.SimpleBindRequest
	}
	newSimpleBindRequestReturnsOnCall map[int]struct {
		result1 *ldap.SimpleBindRequest
	}
	ParseDNStub        func(string) (*ldap.DN, error)
	parseDNMutex       sync.RWMutex
	parseDNArgsForCall []struct {
		arg1 string
	}
	parseDNReturns struct {
		result1 *ldap.DN
		result2 error
	}
	parseDNReturnsOnCall map[int]struct {
		result1 *ldap.DN
		result2 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeV3) CompileFilter(arg1 string) (*ber.Packet, error) {
	fake.compileFilterMutex.Lock()
	ret, specificReturn := fake.compileFilterReturnsOnCall[len(fake.compileFilterArgsForCall)]
	fake.compileFilterArgsForCall = append(fake.compileFilterArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.CompileFilterStub
	fakeReturns := fake.compileFilterReturns
	fake.recordInvocation("CompileFilter", []interface{}{arg1})
	fake.compileFilterMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeV3) CompileFilterCallCount() int {
	fake.compileFilterMutex.RLock()
	defer fake.compileFilterMutex.RUnlock()
	return len(fake.compileFilterArgsForCall)
}

func (fake *FakeV3) CompileFilterCalls(stub func(string) (*ber.Packet, error)) {
	fake.compileFilterMutex.Lock()
	defer fake.compileFilterMutex.Unlock()
	fake.CompileFilterStub = stub
}

func (fake *FakeV3) CompileFilterArgsForCall(i int) string {
	fake.compileFilterMutex.RLock()
	defer fake.compileFilterMutex.RUnlock()
	argsForCall := fake.compileFilterArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeV3) CompileFilterReturns(result1 *ber.Packet, result2 error) {
	fake.compileFilterMutex.Lock()
	defer fake.compileFilterMutex.Unlock()
	fake.CompileFilterStub = nil
	fake.compileFilterReturns = struct {
		result1 *ber.Packet
		result2 error
	}{result1, result2}
}

func (fake *FakeV3) CompileFilterReturnsOnCall(i int, result1 *ber.Packet, result2 error) {
	fake.compileFilterMutex.Lock()
	defer fake.compileFilterMutex.Unlock()
	fake.CompileFilterStub = nil
	if fake.compileFilterReturnsOnCall == nil {
		fake.compileFilterReturnsOnCall = make(map[int]struct {
			result1 *ber.Packet
			result2 error
		})
	}
	fake.compileFilterReturnsOnCall[i] = struct {
		result1 *ber.Packet
		result2 error
	}{result1, result2}
}

func (fake *FakeV3) DebugBinaryFile(arg1 string) error {
	fake.debugBinaryFileMutex.Lock()
	ret, specificReturn := fake.debugBinaryFileReturnsOnCall[len(fake.debugBinaryFileArgsForCall)]
	fake.debugBinaryFileArgsForCall = append(fake.debugBinaryFileArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.DebugBinaryFileStub
	fakeReturns := fake.debugBinaryFileReturns
	fake.recordInvocation("DebugBinaryFile", []interface{}{arg1})
	fake.debugBinaryFileMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeV3) DebugBinaryFileCallCount() int {
	fake.debugBinaryFileMutex.RLock()
	defer fake.debugBinaryFileMutex.RUnlock()
	return len(fake.debugBinaryFileArgsForCall)
}

func (fake *FakeV3) DebugBinaryFileCalls(stub func(string) error) {
	fake.debugBinaryFileMutex.Lock()
	defer fake.debugBinaryFileMutex.Unlock()
	fake.DebugBinaryFileStub = stub
}

func (fake *FakeV3) DebugBinaryFileArgsForCall(i int) string {
	fake.debugBinaryFileMutex.RLock()
	defer fake.debugBinaryFileMutex.RUnlock()
	argsForCall := fake.debugBinaryFileArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeV3) DebugBinaryFileReturns(result1 error) {
	fake.debugBinaryFileMutex.Lock()
	defer fake.debugBinaryFileMutex.Unlock()
	fake.DebugBinaryFileStub = nil
	fake.debugBinaryFileReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeV3) DebugBinaryFileReturnsOnCall(i int, result1 error) {
	fake.debugBinaryFileMutex.Lock()
	defer fake.debugBinaryFileMutex.Unlock()
	fake.DebugBinaryFileStub = nil
	if fake.debugBinaryFileReturnsOnCall == nil {
		fake.debugBinaryFileReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.debugBinaryFileReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeV3) DecodeControl(arg1 *ber.Packet) (ldap.Control, error) {
	fake.decodeControlMutex.Lock()
	ret, specificReturn := fake.decodeControlReturnsOnCall[len(fake.decodeControlArgsForCall)]
	fake.decodeControlArgsForCall = append(fake.decodeControlArgsForCall, struct {
		arg1 *ber.Packet
	}{arg1})
	stub := fake.DecodeControlStub
	fakeReturns := fake.decodeControlReturns
	fake.recordInvocation("DecodeControl", []interface{}{arg1})
	fake.decodeControlMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeV3) DecodeControlCallCount() int {
	fake.decodeControlMutex.RLock()
	defer fake.decodeControlMutex.RUnlock()
	return len(fake.decodeControlArgsForCall)
}

func (fake *FakeV3) DecodeControlCalls(stub func(*ber.Packet) (ldap.Control, error)) {
	fake.decodeControlMutex.Lock()
	defer fake.decodeControlMutex.Unlock()
	fake.DecodeControlStub = stub
}

func (fake *FakeV3) DecodeControlArgsForCall(i int) *ber.Packet {
	fake.decodeControlMutex.RLock()
	defer fake.decodeControlMutex.RUnlock()
	argsForCall := fake.decodeControlArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeV3) DecodeControlReturns(result1 ldap.Control, result2 error) {
	fake.decodeControlMutex.Lock()
	defer fake.decodeControlMutex.Unlock()
	fake.DecodeControlStub = nil
	fake.decodeControlReturns = struct {
		result1 ldap.Control
		result2 error
	}{result1, result2}
}

func (fake *FakeV3) DecodeControlReturnsOnCall(i int, result1 ldap.Control, result2 error) {
	fake.decodeControlMutex.Lock()
	defer fake.decodeControlMutex.Unlock()
	fake.DecodeControlStub = nil
	if fake.decodeControlReturnsOnCall == nil {
		fake.decodeControlReturnsOnCall = make(map[int]struct {
			result1 ldap.Control
			result2 error
		})
	}
	fake.decodeControlReturnsOnCall[i] = struct {
		result1 ldap.Control
		result2 error
	}{result1, result2}
}

func (fake *FakeV3) DecompileFilter(arg1 *ber.Packet) (string, error) {
	fake.decompileFilterMutex.Lock()
	ret, specificReturn := fake.decompileFilterReturnsOnCall[len(fake.decompileFilterArgsForCall)]
	fake.decompileFilterArgsForCall = append(fake.decompileFilterArgsForCall, struct {
		arg1 *ber.Packet
	}{arg1})
	stub := fake.DecompileFilterStub
	fakeReturns := fake.decompileFilterReturns
	fake.recordInvocation("DecompileFilter", []interface{}{arg1})
	fake.decompileFilterMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeV3) DecompileFilterCallCount() int {
	fake.decompileFilterMutex.RLock()
	defer fake.decompileFilterMutex.RUnlock()
	return len(fake.decompileFilterArgsForCall)
}

func (fake *FakeV3) DecompileFilterCalls(stub func(*ber.Packet) (string, error)) {
	fake.decompileFilterMutex.Lock()
	defer fake.decompileFilterMutex.Unlock()
	fake.DecompileFilterStub = stub
}

func (fake *FakeV3) DecompileFilterArgsForCall(i int) *ber.Packet {
	fake.decompileFilterMutex.RLock()
	defer fake.decompileFilterMutex.RUnlock()
	argsForCall := fake.decompileFilterArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeV3) DecompileFilterReturns(result1 string, result2 error) {
	fake.decompileFilterMutex.Lock()
	defer fake.decompileFilterMutex.Unlock()
	fake.DecompileFilterStub = nil
	fake.decompileFilterReturns = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeV3) DecompileFilterReturnsOnCall(i int, result1 string, result2 error) {
	fake.decompileFilterMutex.Lock()
	defer fake.decompileFilterMutex.Unlock()
	fake.DecompileFilterStub = nil
	if fake.decompileFilterReturnsOnCall == nil {
		fake.decompileFilterReturnsOnCall = make(map[int]struct {
			result1 string
			result2 error
		})
	}
	fake.decompileFilterReturnsOnCall[i] = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeV3) Dial(arg1 string, arg2 string) (*ldap.Conn, error) {
	fake.dialMutex.Lock()
	ret, specificReturn := fake.dialReturnsOnCall[len(fake.dialArgsForCall)]
	fake.dialArgsForCall = append(fake.dialArgsForCall, struct {
		arg1 string
		arg2 string
	}{arg1, arg2})
	stub := fake.DialStub
	fakeReturns := fake.dialReturns
	fake.recordInvocation("Dial", []interface{}{arg1, arg2})
	fake.dialMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeV3) DialCallCount() int {
	fake.dialMutex.RLock()
	defer fake.dialMutex.RUnlock()
	return len(fake.dialArgsForCall)
}

func (fake *FakeV3) DialCalls(stub func(string, string) (*ldap.Conn, error)) {
	fake.dialMutex.Lock()
	defer fake.dialMutex.Unlock()
	fake.DialStub = stub
}

func (fake *FakeV3) DialArgsForCall(i int) (string, string) {
	fake.dialMutex.RLock()
	defer fake.dialMutex.RUnlock()
	argsForCall := fake.dialArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeV3) DialReturns(result1 *ldap.Conn, result2 error) {
	fake.dialMutex.Lock()
	defer fake.dialMutex.Unlock()
	fake.DialStub = nil
	fake.dialReturns = struct {
		result1 *ldap.Conn
		result2 error
	}{result1, result2}
}

func (fake *FakeV3) DialReturnsOnCall(i int, result1 *ldap.Conn, result2 error) {
	fake.dialMutex.Lock()
	defer fake.dialMutex.Unlock()
	fake.DialStub = nil
	if fake.dialReturnsOnCall == nil {
		fake.dialReturnsOnCall = make(map[int]struct {
			result1 *ldap.Conn
			result2 error
		})
	}
	fake.dialReturnsOnCall[i] = struct {
		result1 *ldap.Conn
		result2 error
	}{result1, result2}
}

func (fake *FakeV3) DialTLS(arg1 string, arg2 string, arg3 *tls.Config) (*ldap.Conn, error) {
	fake.dialTLSMutex.Lock()
	ret, specificReturn := fake.dialTLSReturnsOnCall[len(fake.dialTLSArgsForCall)]
	fake.dialTLSArgsForCall = append(fake.dialTLSArgsForCall, struct {
		arg1 string
		arg2 string
		arg3 *tls.Config
	}{arg1, arg2, arg3})
	stub := fake.DialTLSStub
	fakeReturns := fake.dialTLSReturns
	fake.recordInvocation("DialTLS", []interface{}{arg1, arg2, arg3})
	fake.dialTLSMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeV3) DialTLSCallCount() int {
	fake.dialTLSMutex.RLock()
	defer fake.dialTLSMutex.RUnlock()
	return len(fake.dialTLSArgsForCall)
}

func (fake *FakeV3) DialTLSCalls(stub func(string, string, *tls.Config) (*ldap.Conn, error)) {
	fake.dialTLSMutex.Lock()
	defer fake.dialTLSMutex.Unlock()
	fake.DialTLSStub = stub
}

func (fake *FakeV3) DialTLSArgsForCall(i int) (string, string, *tls.Config) {
	fake.dialTLSMutex.RLock()
	defer fake.dialTLSMutex.RUnlock()
	argsForCall := fake.dialTLSArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeV3) DialTLSReturns(result1 *ldap.Conn, result2 error) {
	fake.dialTLSMutex.Lock()
	defer fake.dialTLSMutex.Unlock()
	fake.DialTLSStub = nil
	fake.dialTLSReturns = struct {
		result1 *ldap.Conn
		result2 error
	}{result1, result2}
}

func (fake *FakeV3) DialTLSReturnsOnCall(i int, result1 *ldap.Conn, result2 error) {
	fake.dialTLSMutex.Lock()
	defer fake.dialTLSMutex.Unlock()
	fake.DialTLSStub = nil
	if fake.dialTLSReturnsOnCall == nil {
		fake.dialTLSReturnsOnCall = make(map[int]struct {
			result1 *ldap.Conn
			result2 error
		})
	}
	fake.dialTLSReturnsOnCall[i] = struct {
		result1 *ldap.Conn
		result2 error
	}{result1, result2}
}

func (fake *FakeV3) DialURL(arg1 string, arg2 ...ldap.DialOpt) (*ldap.Conn, error) {
	fake.dialURLMutex.Lock()
	ret, specificReturn := fake.dialURLReturnsOnCall[len(fake.dialURLArgsForCall)]
	fake.dialURLArgsForCall = append(fake.dialURLArgsForCall, struct {
		arg1 string
		arg2 []ldap.DialOpt
	}{arg1, arg2})
	stub := fake.DialURLStub
	fakeReturns := fake.dialURLReturns
	fake.recordInvocation("DialURL", []interface{}{arg1, arg2})
	fake.dialURLMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeV3) DialURLCallCount() int {
	fake.dialURLMutex.RLock()
	defer fake.dialURLMutex.RUnlock()
	return len(fake.dialURLArgsForCall)
}

func (fake *FakeV3) DialURLCalls(stub func(string, ...ldap.DialOpt) (*ldap.Conn, error)) {
	fake.dialURLMutex.Lock()
	defer fake.dialURLMutex.Unlock()
	fake.DialURLStub = stub
}

func (fake *FakeV3) DialURLArgsForCall(i int) (string, []ldap.DialOpt) {
	fake.dialURLMutex.RLock()
	defer fake.dialURLMutex.RUnlock()
	argsForCall := fake.dialURLArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeV3) DialURLReturns(result1 *ldap.Conn, result2 error) {
	fake.dialURLMutex.Lock()
	defer fake.dialURLMutex.Unlock()
	fake.DialURLStub = nil
	fake.dialURLReturns = struct {
		result1 *ldap.Conn
		result2 error
	}{result1, result2}
}

func (fake *FakeV3) DialURLReturnsOnCall(i int, result1 *ldap.Conn, result2 error) {
	fake.dialURLMutex.Lock()
	defer fake.dialURLMutex.Unlock()
	fake.DialURLStub = nil
	if fake.dialURLReturnsOnCall == nil {
		fake.dialURLReturnsOnCall = make(map[int]struct {
			result1 *ldap.Conn
			result2 error
		})
	}
	fake.dialURLReturnsOnCall[i] = struct {
		result1 *ldap.Conn
		result2 error
	}{result1, result2}
}

func (fake *FakeV3) DialWithDialer(arg1 *net.Dialer) ldap.DialOpt {
	fake.dialWithDialerMutex.Lock()
	ret, specificReturn := fake.dialWithDialerReturnsOnCall[len(fake.dialWithDialerArgsForCall)]
	fake.dialWithDialerArgsForCall = append(fake.dialWithDialerArgsForCall, struct {
		arg1 *net.Dialer
	}{arg1})
	stub := fake.DialWithDialerStub
	fakeReturns := fake.dialWithDialerReturns
	fake.recordInvocation("DialWithDialer", []interface{}{arg1})
	fake.dialWithDialerMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeV3) DialWithDialerCallCount() int {
	fake.dialWithDialerMutex.RLock()
	defer fake.dialWithDialerMutex.RUnlock()
	return len(fake.dialWithDialerArgsForCall)
}

func (fake *FakeV3) DialWithDialerCalls(stub func(*net.Dialer) ldap.DialOpt) {
	fake.dialWithDialerMutex.Lock()
	defer fake.dialWithDialerMutex.Unlock()
	fake.DialWithDialerStub = stub
}

func (fake *FakeV3) DialWithDialerArgsForCall(i int) *net.Dialer {
	fake.dialWithDialerMutex.RLock()
	defer fake.dialWithDialerMutex.RUnlock()
	argsForCall := fake.dialWithDialerArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeV3) DialWithDialerReturns(result1 ldap.DialOpt) {
	fake.dialWithDialerMutex.Lock()
	defer fake.dialWithDialerMutex.Unlock()
	fake.DialWithDialerStub = nil
	fake.dialWithDialerReturns = struct {
		result1 ldap.DialOpt
	}{result1}
}

func (fake *FakeV3) DialWithDialerReturnsOnCall(i int, result1 ldap.DialOpt) {
	fake.dialWithDialerMutex.Lock()
	defer fake.dialWithDialerMutex.Unlock()
	fake.DialWithDialerStub = nil
	if fake.dialWithDialerReturnsOnCall == nil {
		fake.dialWithDialerReturnsOnCall = make(map[int]struct {
			result1 ldap.DialOpt
		})
	}
	fake.dialWithDialerReturnsOnCall[i] = struct {
		result1 ldap.DialOpt
	}{result1}
}

func (fake *FakeV3) DialWithTLSConfig(arg1 *tls.Config) ldap.DialOpt {
	fake.dialWithTLSConfigMutex.Lock()
	ret, specificReturn := fake.dialWithTLSConfigReturnsOnCall[len(fake.dialWithTLSConfigArgsForCall)]
	fake.dialWithTLSConfigArgsForCall = append(fake.dialWithTLSConfigArgsForCall, struct {
		arg1 *tls.Config
	}{arg1})
	stub := fake.DialWithTLSConfigStub
	fakeReturns := fake.dialWithTLSConfigReturns
	fake.recordInvocation("DialWithTLSConfig", []interface{}{arg1})
	fake.dialWithTLSConfigMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeV3) DialWithTLSConfigCallCount() int {
	fake.dialWithTLSConfigMutex.RLock()
	defer fake.dialWithTLSConfigMutex.RUnlock()
	return len(fake.dialWithTLSConfigArgsForCall)
}

func (fake *FakeV3) DialWithTLSConfigCalls(stub func(*tls.Config) ldap.DialOpt) {
	fake.dialWithTLSConfigMutex.Lock()
	defer fake.dialWithTLSConfigMutex.Unlock()
	fake.DialWithTLSConfigStub = stub
}

func (fake *FakeV3) DialWithTLSConfigArgsForCall(i int) *tls.Config {
	fake.dialWithTLSConfigMutex.RLock()
	defer fake.dialWithTLSConfigMutex.RUnlock()
	argsForCall := fake.dialWithTLSConfigArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeV3) DialWithTLSConfigReturns(result1 ldap.DialOpt) {
	fake.dialWithTLSConfigMutex.Lock()
	defer fake.dialWithTLSConfigMutex.Unlock()
	fake.DialWithTLSConfigStub = nil
	fake.dialWithTLSConfigReturns = struct {
		result1 ldap.DialOpt
	}{result1}
}

func (fake *FakeV3) DialWithTLSConfigReturnsOnCall(i int, result1 ldap.DialOpt) {
	fake.dialWithTLSConfigMutex.Lock()
	defer fake.dialWithTLSConfigMutex.Unlock()
	fake.DialWithTLSConfigStub = nil
	if fake.dialWithTLSConfigReturnsOnCall == nil {
		fake.dialWithTLSConfigReturnsOnCall = make(map[int]struct {
			result1 ldap.DialOpt
		})
	}
	fake.dialWithTLSConfigReturnsOnCall[i] = struct {
		result1 ldap.DialOpt
	}{result1}
}

func (fake *FakeV3) DialWithTLSDialer(arg1 *tls.Config, arg2 *net.Dialer) ldap.DialOpt {
	fake.dialWithTLSDialerMutex.Lock()
	ret, specificReturn := fake.dialWithTLSDialerReturnsOnCall[len(fake.dialWithTLSDialerArgsForCall)]
	fake.dialWithTLSDialerArgsForCall = append(fake.dialWithTLSDialerArgsForCall, struct {
		arg1 *tls.Config
		arg2 *net.Dialer
	}{arg1, arg2})
	stub := fake.DialWithTLSDialerStub
	fakeReturns := fake.dialWithTLSDialerReturns
	fake.recordInvocation("DialWithTLSDialer", []interface{}{arg1, arg2})
	fake.dialWithTLSDialerMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeV3) DialWithTLSDialerCallCount() int {
	fake.dialWithTLSDialerMutex.RLock()
	defer fake.dialWithTLSDialerMutex.RUnlock()
	return len(fake.dialWithTLSDialerArgsForCall)
}

func (fake *FakeV3) DialWithTLSDialerCalls(stub func(*tls.Config, *net.Dialer) ldap.DialOpt) {
	fake.dialWithTLSDialerMutex.Lock()
	defer fake.dialWithTLSDialerMutex.Unlock()
	fake.DialWithTLSDialerStub = stub
}

func (fake *FakeV3) DialWithTLSDialerArgsForCall(i int) (*tls.Config, *net.Dialer) {
	fake.dialWithTLSDialerMutex.RLock()
	defer fake.dialWithTLSDialerMutex.RUnlock()
	argsForCall := fake.dialWithTLSDialerArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeV3) DialWithTLSDialerReturns(result1 ldap.DialOpt) {
	fake.dialWithTLSDialerMutex.Lock()
	defer fake.dialWithTLSDialerMutex.Unlock()
	fake.DialWithTLSDialerStub = nil
	fake.dialWithTLSDialerReturns = struct {
		result1 ldap.DialOpt
	}{result1}
}

func (fake *FakeV3) DialWithTLSDialerReturnsOnCall(i int, result1 ldap.DialOpt) {
	fake.dialWithTLSDialerMutex.Lock()
	defer fake.dialWithTLSDialerMutex.Unlock()
	fake.DialWithTLSDialerStub = nil
	if fake.dialWithTLSDialerReturnsOnCall == nil {
		fake.dialWithTLSDialerReturnsOnCall = make(map[int]struct {
			result1 ldap.DialOpt
		})
	}
	fake.dialWithTLSDialerReturnsOnCall[i] = struct {
		result1 ldap.DialOpt
	}{result1}
}

func (fake *FakeV3) EscapeFilter(arg1 string) string {
	fake.escapeFilterMutex.Lock()
	ret, specificReturn := fake.escapeFilterReturnsOnCall[len(fake.escapeFilterArgsForCall)]
	fake.escapeFilterArgsForCall = append(fake.escapeFilterArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.EscapeFilterStub
	fakeReturns := fake.escapeFilterReturns
	fake.recordInvocation("EscapeFilter", []interface{}{arg1})
	fake.escapeFilterMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeV3) EscapeFilterCallCount() int {
	fake.escapeFilterMutex.RLock()
	defer fake.escapeFilterMutex.RUnlock()
	return len(fake.escapeFilterArgsForCall)
}

func (fake *FakeV3) EscapeFilterCalls(stub func(string) string) {
	fake.escapeFilterMutex.Lock()
	defer fake.escapeFilterMutex.Unlock()
	fake.EscapeFilterStub = stub
}

func (fake *FakeV3) EscapeFilterArgsForCall(i int) string {
	fake.escapeFilterMutex.RLock()
	defer fake.escapeFilterMutex.RUnlock()
	argsForCall := fake.escapeFilterArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeV3) EscapeFilterReturns(result1 string) {
	fake.escapeFilterMutex.Lock()
	defer fake.escapeFilterMutex.Unlock()
	fake.EscapeFilterStub = nil
	fake.escapeFilterReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeV3) EscapeFilterReturnsOnCall(i int, result1 string) {
	fake.escapeFilterMutex.Lock()
	defer fake.escapeFilterMutex.Unlock()
	fake.EscapeFilterStub = nil
	if fake.escapeFilterReturnsOnCall == nil {
		fake.escapeFilterReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.escapeFilterReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeV3) FindControl(arg1 []ldap.Control, arg2 string) ldap.Control {
	var arg1Copy []ldap.Control
	if arg1 != nil {
		arg1Copy = make([]ldap.Control, len(arg1))
		copy(arg1Copy, arg1)
	}
	fake.findControlMutex.Lock()
	ret, specificReturn := fake.findControlReturnsOnCall[len(fake.findControlArgsForCall)]
	fake.findControlArgsForCall = append(fake.findControlArgsForCall, struct {
		arg1 []ldap.Control
		arg2 string
	}{arg1Copy, arg2})
	stub := fake.FindControlStub
	fakeReturns := fake.findControlReturns
	fake.recordInvocation("FindControl", []interface{}{arg1Copy, arg2})
	fake.findControlMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeV3) FindControlCallCount() int {
	fake.findControlMutex.RLock()
	defer fake.findControlMutex.RUnlock()
	return len(fake.findControlArgsForCall)
}

func (fake *FakeV3) FindControlCalls(stub func([]ldap.Control, string) ldap.Control) {
	fake.findControlMutex.Lock()
	defer fake.findControlMutex.Unlock()
	fake.FindControlStub = stub
}

func (fake *FakeV3) FindControlArgsForCall(i int) ([]ldap.Control, string) {
	fake.findControlMutex.RLock()
	defer fake.findControlMutex.RUnlock()
	argsForCall := fake.findControlArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeV3) FindControlReturns(result1 ldap.Control) {
	fake.findControlMutex.Lock()
	defer fake.findControlMutex.Unlock()
	fake.FindControlStub = nil
	fake.findControlReturns = struct {
		result1 ldap.Control
	}{result1}
}

func (fake *FakeV3) FindControlReturnsOnCall(i int, result1 ldap.Control) {
	fake.findControlMutex.Lock()
	defer fake.findControlMutex.Unlock()
	fake.FindControlStub = nil
	if fake.findControlReturnsOnCall == nil {
		fake.findControlReturnsOnCall = make(map[int]struct {
			result1 ldap.Control
		})
	}
	fake.findControlReturnsOnCall[i] = struct {
		result1 ldap.Control
	}{result1}
}

func (fake *FakeV3) GetLDAPError(arg1 *ber.Packet) error {
	fake.getLDAPErrorMutex.Lock()
	ret, specificReturn := fake.getLDAPErrorReturnsOnCall[len(fake.getLDAPErrorArgsForCall)]
	fake.getLDAPErrorArgsForCall = append(fake.getLDAPErrorArgsForCall, struct {
		arg1 *ber.Packet
	}{arg1})
	stub := fake.GetLDAPErrorStub
	fakeReturns := fake.getLDAPErrorReturns
	fake.recordInvocation("GetLDAPError", []interface{}{arg1})
	fake.getLDAPErrorMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeV3) GetLDAPErrorCallCount() int {
	fake.getLDAPErrorMutex.RLock()
	defer fake.getLDAPErrorMutex.RUnlock()
	return len(fake.getLDAPErrorArgsForCall)
}

func (fake *FakeV3) GetLDAPErrorCalls(stub func(*ber.Packet) error) {
	fake.getLDAPErrorMutex.Lock()
	defer fake.getLDAPErrorMutex.Unlock()
	fake.GetLDAPErrorStub = stub
}

func (fake *FakeV3) GetLDAPErrorArgsForCall(i int) *ber.Packet {
	fake.getLDAPErrorMutex.RLock()
	defer fake.getLDAPErrorMutex.RUnlock()
	argsForCall := fake.getLDAPErrorArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeV3) GetLDAPErrorReturns(result1 error) {
	fake.getLDAPErrorMutex.Lock()
	defer fake.getLDAPErrorMutex.Unlock()
	fake.GetLDAPErrorStub = nil
	fake.getLDAPErrorReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeV3) GetLDAPErrorReturnsOnCall(i int, result1 error) {
	fake.getLDAPErrorMutex.Lock()
	defer fake.getLDAPErrorMutex.Unlock()
	fake.GetLDAPErrorStub = nil
	if fake.getLDAPErrorReturnsOnCall == nil {
		fake.getLDAPErrorReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.getLDAPErrorReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeV3) IsErrorAnyOf(arg1 error, arg2 ...uint16) bool {
	fake.isErrorAnyOfMutex.Lock()
	ret, specificReturn := fake.isErrorAnyOfReturnsOnCall[len(fake.isErrorAnyOfArgsForCall)]
	fake.isErrorAnyOfArgsForCall = append(fake.isErrorAnyOfArgsForCall, struct {
		arg1 error
		arg2 []uint16
	}{arg1, arg2})
	stub := fake.IsErrorAnyOfStub
	fakeReturns := fake.isErrorAnyOfReturns
	fake.recordInvocation("IsErrorAnyOf", []interface{}{arg1, arg2})
	fake.isErrorAnyOfMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2...)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeV3) IsErrorAnyOfCallCount() int {
	fake.isErrorAnyOfMutex.RLock()
	defer fake.isErrorAnyOfMutex.RUnlock()
	return len(fake.isErrorAnyOfArgsForCall)
}

func (fake *FakeV3) IsErrorAnyOfCalls(stub func(error, ...uint16) bool) {
	fake.isErrorAnyOfMutex.Lock()
	defer fake.isErrorAnyOfMutex.Unlock()
	fake.IsErrorAnyOfStub = stub
}

func (fake *FakeV3) IsErrorAnyOfArgsForCall(i int) (error, []uint16) {
	fake.isErrorAnyOfMutex.RLock()
	defer fake.isErrorAnyOfMutex.RUnlock()
	argsForCall := fake.isErrorAnyOfArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeV3) IsErrorAnyOfReturns(result1 bool) {
	fake.isErrorAnyOfMutex.Lock()
	defer fake.isErrorAnyOfMutex.Unlock()
	fake.IsErrorAnyOfStub = nil
	fake.isErrorAnyOfReturns = struct {
		result1 bool
	}{result1}
}

func (fake *FakeV3) IsErrorAnyOfReturnsOnCall(i int, result1 bool) {
	fake.isErrorAnyOfMutex.Lock()
	defer fake.isErrorAnyOfMutex.Unlock()
	fake.IsErrorAnyOfStub = nil
	if fake.isErrorAnyOfReturnsOnCall == nil {
		fake.isErrorAnyOfReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.isErrorAnyOfReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *FakeV3) IsErrorWithCode(arg1 error, arg2 uint16) bool {
	fake.isErrorWithCodeMutex.Lock()
	ret, specificReturn := fake.isErrorWithCodeReturnsOnCall[len(fake.isErrorWithCodeArgsForCall)]
	fake.isErrorWithCodeArgsForCall = append(fake.isErrorWithCodeArgsForCall, struct {
		arg1 error
		arg2 uint16
	}{arg1, arg2})
	stub := fake.IsErrorWithCodeStub
	fakeReturns := fake.isErrorWithCodeReturns
	fake.recordInvocation("IsErrorWithCode", []interface{}{arg1, arg2})
	fake.isErrorWithCodeMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeV3) IsErrorWithCodeCallCount() int {
	fake.isErrorWithCodeMutex.RLock()
	defer fake.isErrorWithCodeMutex.RUnlock()
	return len(fake.isErrorWithCodeArgsForCall)
}

func (fake *FakeV3) IsErrorWithCodeCalls(stub func(error, uint16) bool) {
	fake.isErrorWithCodeMutex.Lock()
	defer fake.isErrorWithCodeMutex.Unlock()
	fake.IsErrorWithCodeStub = stub
}

func (fake *FakeV3) IsErrorWithCodeArgsForCall(i int) (error, uint16) {
	fake.isErrorWithCodeMutex.RLock()
	defer fake.isErrorWithCodeMutex.RUnlock()
	argsForCall := fake.isErrorWithCodeArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeV3) IsErrorWithCodeReturns(result1 bool) {
	fake.isErrorWithCodeMutex.Lock()
	defer fake.isErrorWithCodeMutex.Unlock()
	fake.IsErrorWithCodeStub = nil
	fake.isErrorWithCodeReturns = struct {
		result1 bool
	}{result1}
}

func (fake *FakeV3) IsErrorWithCodeReturnsOnCall(i int, result1 bool) {
	fake.isErrorWithCodeMutex.Lock()
	defer fake.isErrorWithCodeMutex.Unlock()
	fake.IsErrorWithCodeStub = nil
	if fake.isErrorWithCodeReturnsOnCall == nil {
		fake.isErrorWithCodeReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.isErrorWithCodeReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *FakeV3) Logger(arg1 *log.Logger) {
	fake.loggerMutex.Lock()
	fake.loggerArgsForCall = append(fake.loggerArgsForCall, struct {
		arg1 *log.Logger
	}{arg1})
	stub := fake.LoggerStub
	fake.recordInvocation("Logger", []interface{}{arg1})
	fake.loggerMutex.Unlock()
	if stub != nil {
		fake.LoggerStub(arg1)
	}
}

func (fake *FakeV3) LoggerCallCount() int {
	fake.loggerMutex.RLock()
	defer fake.loggerMutex.RUnlock()
	return len(fake.loggerArgsForCall)
}

func (fake *FakeV3) LoggerCalls(stub func(*log.Logger)) {
	fake.loggerMutex.Lock()
	defer fake.loggerMutex.Unlock()
	fake.LoggerStub = stub
}

func (fake *FakeV3) LoggerArgsForCall(i int) *log.Logger {
	fake.loggerMutex.RLock()
	defer fake.loggerMutex.RUnlock()
	argsForCall := fake.loggerArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeV3) NewAddRequest(arg1 string, arg2 []ldap.Control) *ldap.AddRequest {
	var arg2Copy []ldap.Control
	if arg2 != nil {
		arg2Copy = make([]ldap.Control, len(arg2))
		copy(arg2Copy, arg2)
	}
	fake.newAddRequestMutex.Lock()
	ret, specificReturn := fake.newAddRequestReturnsOnCall[len(fake.newAddRequestArgsForCall)]
	fake.newAddRequestArgsForCall = append(fake.newAddRequestArgsForCall, struct {
		arg1 string
		arg2 []ldap.Control
	}{arg1, arg2Copy})
	stub := fake.NewAddRequestStub
	fakeReturns := fake.newAddRequestReturns
	fake.recordInvocation("NewAddRequest", []interface{}{arg1, arg2Copy})
	fake.newAddRequestMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeV3) NewAddRequestCallCount() int {
	fake.newAddRequestMutex.RLock()
	defer fake.newAddRequestMutex.RUnlock()
	return len(fake.newAddRequestArgsForCall)
}

func (fake *FakeV3) NewAddRequestCalls(stub func(string, []ldap.Control) *ldap.AddRequest) {
	fake.newAddRequestMutex.Lock()
	defer fake.newAddRequestMutex.Unlock()
	fake.NewAddRequestStub = stub
}

func (fake *FakeV3) NewAddRequestArgsForCall(i int) (string, []ldap.Control) {
	fake.newAddRequestMutex.RLock()
	defer fake.newAddRequestMutex.RUnlock()
	argsForCall := fake.newAddRequestArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeV3) NewAddRequestReturns(result1 *ldap.AddRequest) {
	fake.newAddRequestMutex.Lock()
	defer fake.newAddRequestMutex.Unlock()
	fake.NewAddRequestStub = nil
	fake.newAddRequestReturns = struct {
		result1 *ldap.AddRequest
	}{result1}
}

func (fake *FakeV3) NewAddRequestReturnsOnCall(i int, result1 *ldap.AddRequest) {
	fake.newAddRequestMutex.Lock()
	defer fake.newAddRequestMutex.Unlock()
	fake.NewAddRequestStub = nil
	if fake.newAddRequestReturnsOnCall == nil {
		fake.newAddRequestReturnsOnCall = make(map[int]struct {
			result1 *ldap.AddRequest
		})
	}
	fake.newAddRequestReturnsOnCall[i] = struct {
		result1 *ldap.AddRequest
	}{result1}
}

func (fake *FakeV3) NewConn(arg1 net.Conn, arg2 bool) *ldap.Conn {
	fake.newConnMutex.Lock()
	ret, specificReturn := fake.newConnReturnsOnCall[len(fake.newConnArgsForCall)]
	fake.newConnArgsForCall = append(fake.newConnArgsForCall, struct {
		arg1 net.Conn
		arg2 bool
	}{arg1, arg2})
	stub := fake.NewConnStub
	fakeReturns := fake.newConnReturns
	fake.recordInvocation("NewConn", []interface{}{arg1, arg2})
	fake.newConnMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeV3) NewConnCallCount() int {
	fake.newConnMutex.RLock()
	defer fake.newConnMutex.RUnlock()
	return len(fake.newConnArgsForCall)
}

func (fake *FakeV3) NewConnCalls(stub func(net.Conn, bool) *ldap.Conn) {
	fake.newConnMutex.Lock()
	defer fake.newConnMutex.Unlock()
	fake.NewConnStub = stub
}

func (fake *FakeV3) NewConnArgsForCall(i int) (net.Conn, bool) {
	fake.newConnMutex.RLock()
	defer fake.newConnMutex.RUnlock()
	argsForCall := fake.newConnArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeV3) NewConnReturns(result1 *ldap.Conn) {
	fake.newConnMutex.Lock()
	defer fake.newConnMutex.Unlock()
	fake.NewConnStub = nil
	fake.newConnReturns = struct {
		result1 *ldap.Conn
	}{result1}
}

func (fake *FakeV3) NewConnReturnsOnCall(i int, result1 *ldap.Conn) {
	fake.newConnMutex.Lock()
	defer fake.newConnMutex.Unlock()
	fake.NewConnStub = nil
	if fake.newConnReturnsOnCall == nil {
		fake.newConnReturnsOnCall = make(map[int]struct {
			result1 *ldap.Conn
		})
	}
	fake.newConnReturnsOnCall[i] = struct {
		result1 *ldap.Conn
	}{result1}
}

func (fake *FakeV3) NewControlBeheraPasswordPolicy() *ldap.ControlBeheraPasswordPolicy {
	fake.newControlBeheraPasswordPolicyMutex.Lock()
	ret, specificReturn := fake.newControlBeheraPasswordPolicyReturnsOnCall[len(fake.newControlBeheraPasswordPolicyArgsForCall)]
	fake.newControlBeheraPasswordPolicyArgsForCall = append(fake.newControlBeheraPasswordPolicyArgsForCall, struct {
	}{})
	stub := fake.NewControlBeheraPasswordPolicyStub
	fakeReturns := fake.newControlBeheraPasswordPolicyReturns
	fake.recordInvocation("NewControlBeheraPasswordPolicy", []interface{}{})
	fake.newControlBeheraPasswordPolicyMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeV3) NewControlBeheraPasswordPolicyCallCount() int {
	fake.newControlBeheraPasswordPolicyMutex.RLock()
	defer fake.newControlBeheraPasswordPolicyMutex.RUnlock()
	return len(fake.newControlBeheraPasswordPolicyArgsForCall)
}

func (fake *FakeV3) NewControlBeheraPasswordPolicyCalls(stub func() *ldap.ControlBeheraPasswordPolicy) {
	fake.newControlBeheraPasswordPolicyMutex.Lock()
	defer fake.newControlBeheraPasswordPolicyMutex.Unlock()
	fake.NewControlBeheraPasswordPolicyStub = stub
}

func (fake *FakeV3) NewControlBeheraPasswordPolicyReturns(result1 *ldap.ControlBeheraPasswordPolicy) {
	fake.newControlBeheraPasswordPolicyMutex.Lock()
	defer fake.newControlBeheraPasswordPolicyMutex.Unlock()
	fake.NewControlBeheraPasswordPolicyStub = nil
	fake.newControlBeheraPasswordPolicyReturns = struct {
		result1 *ldap.ControlBeheraPasswordPolicy
	}{result1}
}

func (fake *FakeV3) NewControlBeheraPasswordPolicyReturnsOnCall(i int, result1 *ldap.ControlBeheraPasswordPolicy) {
	fake.newControlBeheraPasswordPolicyMutex.Lock()
	defer fake.newControlBeheraPasswordPolicyMutex.Unlock()
	fake.NewControlBeheraPasswordPolicyStub = nil
	if fake.newControlBeheraPasswordPolicyReturnsOnCall == nil {
		fake.newControlBeheraPasswordPolicyReturnsOnCall = make(map[int]struct {
			result1 *ldap.ControlBeheraPasswordPolicy
		})
	}
	fake.newControlBeheraPasswordPolicyReturnsOnCall[i] = struct {
		result1 *ldap.ControlBeheraPasswordPolicy
	}{result1}
}

func (fake *FakeV3) NewControlManageDsaIT(arg1 bool) *ldap.ControlManageDsaIT {
	fake.newControlManageDsaITMutex.Lock()
	ret, specificReturn := fake.newControlManageDsaITReturnsOnCall[len(fake.newControlManageDsaITArgsForCall)]
	fake.newControlManageDsaITArgsForCall = append(fake.newControlManageDsaITArgsForCall, struct {
		arg1 bool
	}{arg1})
	stub := fake.NewControlManageDsaITStub
	fakeReturns := fake.newControlManageDsaITReturns
	fake.recordInvocation("NewControlManageDsaIT", []interface{}{arg1})
	fake.newControlManageDsaITMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeV3) NewControlManageDsaITCallCount() int {
	fake.newControlManageDsaITMutex.RLock()
	defer fake.newControlManageDsaITMutex.RUnlock()
	return len(fake.newControlManageDsaITArgsForCall)
}

func (fake *FakeV3) NewControlManageDsaITCalls(stub func(bool) *ldap.ControlManageDsaIT) {
	fake.newControlManageDsaITMutex.Lock()
	defer fake.newControlManageDsaITMutex.Unlock()
	fake.NewControlManageDsaITStub = stub
}

func (fake *FakeV3) NewControlManageDsaITArgsForCall(i int) bool {
	fake.newControlManageDsaITMutex.RLock()
	defer fake.newControlManageDsaITMutex.RUnlock()
	argsForCall := fake.newControlManageDsaITArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeV3) NewControlManageDsaITReturns(result1 *ldap.ControlManageDsaIT) {
	fake.newControlManageDsaITMutex.Lock()
	defer fake.newControlManageDsaITMutex.Unlock()
	fake.NewControlManageDsaITStub = nil
	fake.newControlManageDsaITReturns = struct {
		result1 *ldap.ControlManageDsaIT
	}{result1}
}

func (fake *FakeV3) NewControlManageDsaITReturnsOnCall(i int, result1 *ldap.ControlManageDsaIT) {
	fake.newControlManageDsaITMutex.Lock()
	defer fake.newControlManageDsaITMutex.Unlock()
	fake.NewControlManageDsaITStub = nil
	if fake.newControlManageDsaITReturnsOnCall == nil {
		fake.newControlManageDsaITReturnsOnCall = make(map[int]struct {
			result1 *ldap.ControlManageDsaIT
		})
	}
	fake.newControlManageDsaITReturnsOnCall[i] = struct {
		result1 *ldap.ControlManageDsaIT
	}{result1}
}

func (fake *FakeV3) NewControlMicrosoftNotification() *ldap.ControlMicrosoftNotification {
	fake.newControlMicrosoftNotificationMutex.Lock()
	ret, specificReturn := fake.newControlMicrosoftNotificationReturnsOnCall[len(fake.newControlMicrosoftNotificationArgsForCall)]
	fake.newControlMicrosoftNotificationArgsForCall = append(fake.newControlMicrosoftNotificationArgsForCall, struct {
	}{})
	stub := fake.NewControlMicrosoftNotificationStub
	fakeReturns := fake.newControlMicrosoftNotificationReturns
	fake.recordInvocation("NewControlMicrosoftNotification", []interface{}{})
	fake.newControlMicrosoftNotificationMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeV3) NewControlMicrosoftNotificationCallCount() int {
	fake.newControlMicrosoftNotificationMutex.RLock()
	defer fake.newControlMicrosoftNotificationMutex.RUnlock()
	return len(fake.newControlMicrosoftNotificationArgsForCall)
}

func (fake *FakeV3) NewControlMicrosoftNotificationCalls(stub func() *ldap.ControlMicrosoftNotification) {
	fake.newControlMicrosoftNotificationMutex.Lock()
	defer fake.newControlMicrosoftNotificationMutex.Unlock()
	fake.NewControlMicrosoftNotificationStub = stub
}

func (fake *FakeV3) NewControlMicrosoftNotificationReturns(result1 *ldap.ControlMicrosoftNotification) {
	fake.newControlMicrosoftNotificationMutex.Lock()
	defer fake.newControlMicrosoftNotificationMutex.Unlock()
	fake.NewControlMicrosoftNotificationStub = nil
	fake.newControlMicrosoftNotificationReturns = struct {
		result1 *ldap.ControlMicrosoftNotification
	}{result1}
}

func (fake *FakeV3) NewControlMicrosoftNotificationReturnsOnCall(i int, result1 *ldap.ControlMicrosoftNotification) {
	fake.newControlMicrosoftNotificationMutex.Lock()
	defer fake.newControlMicrosoftNotificationMutex.Unlock()
	fake.NewControlMicrosoftNotificationStub = nil
	if fake.newControlMicrosoftNotificationReturnsOnCall == nil {
		fake.newControlMicrosoftNotificationReturnsOnCall = make(map[int]struct {
			result1 *ldap.ControlMicrosoftNotification
		})
	}
	fake.newControlMicrosoftNotificationReturnsOnCall[i] = struct {
		result1 *ldap.ControlMicrosoftNotification
	}{result1}
}

func (fake *FakeV3) NewControlMicrosoftServerLinkTTL() *ldap.ControlMicrosoftServerLinkTTL {
	fake.newControlMicrosoftServerLinkTTLMutex.Lock()
	ret, specificReturn := fake.newControlMicrosoftServerLinkTTLReturnsOnCall[len(fake.newControlMicrosoftServerLinkTTLArgsForCall)]
	fake.newControlMicrosoftServerLinkTTLArgsForCall = append(fake.newControlMicrosoftServerLinkTTLArgsForCall, struct {
	}{})
	stub := fake.NewControlMicrosoftServerLinkTTLStub
	fakeReturns := fake.newControlMicrosoftServerLinkTTLReturns
	fake.recordInvocation("NewControlMicrosoftServerLinkTTL", []interface{}{})
	fake.newControlMicrosoftServerLinkTTLMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeV3) NewControlMicrosoftServerLinkTTLCallCount() int {
	fake.newControlMicrosoftServerLinkTTLMutex.RLock()
	defer fake.newControlMicrosoftServerLinkTTLMutex.RUnlock()
	return len(fake.newControlMicrosoftServerLinkTTLArgsForCall)
}

func (fake *FakeV3) NewControlMicrosoftServerLinkTTLCalls(stub func() *ldap.ControlMicrosoftServerLinkTTL) {
	fake.newControlMicrosoftServerLinkTTLMutex.Lock()
	defer fake.newControlMicrosoftServerLinkTTLMutex.Unlock()
	fake.NewControlMicrosoftServerLinkTTLStub = stub
}

func (fake *FakeV3) NewControlMicrosoftServerLinkTTLReturns(result1 *ldap.ControlMicrosoftServerLinkTTL) {
	fake.newControlMicrosoftServerLinkTTLMutex.Lock()
	defer fake.newControlMicrosoftServerLinkTTLMutex.Unlock()
	fake.NewControlMicrosoftServerLinkTTLStub = nil
	fake.newControlMicrosoftServerLinkTTLReturns = struct {
		result1 *ldap.ControlMicrosoftServerLinkTTL
	}{result1}
}

func (fake *FakeV3) NewControlMicrosoftServerLinkTTLReturnsOnCall(i int, result1 *ldap.ControlMicrosoftServerLinkTTL) {
	fake.newControlMicrosoftServerLinkTTLMutex.Lock()
	defer fake.newControlMicrosoftServerLinkTTLMutex.Unlock()
	fake.NewControlMicrosoftServerLinkTTLStub = nil
	if fake.newControlMicrosoftServerLinkTTLReturnsOnCall == nil {
		fake.newControlMicrosoftServerLinkTTLReturnsOnCall = make(map[int]struct {
			result1 *ldap.ControlMicrosoftServerLinkTTL
		})
	}
	fake.newControlMicrosoftServerLinkTTLReturnsOnCall[i] = struct {
		result1 *ldap.ControlMicrosoftServerLinkTTL
	}{result1}
}

func (fake *FakeV3) NewControlMicrosoftShowDeleted() *ldap.ControlMicrosoftShowDeleted {
	fake.newControlMicrosoftShowDeletedMutex.Lock()
	ret, specificReturn := fake.newControlMicrosoftShowDeletedReturnsOnCall[len(fake.newControlMicrosoftShowDeletedArgsForCall)]
	fake.newControlMicrosoftShowDeletedArgsForCall = append(fake.newControlMicrosoftShowDeletedArgsForCall, struct {
	}{})
	stub := fake.NewControlMicrosoftShowDeletedStub
	fakeReturns := fake.newControlMicrosoftShowDeletedReturns
	fake.recordInvocation("NewControlMicrosoftShowDeleted", []interface{}{})
	fake.newControlMicrosoftShowDeletedMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeV3) NewControlMicrosoftShowDeletedCallCount() int {
	fake.newControlMicrosoftShowDeletedMutex.RLock()
	defer fake.newControlMicrosoftShowDeletedMutex.RUnlock()
	return len(fake.newControlMicrosoftShowDeletedArgsForCall)
}

func (fake *FakeV3) NewControlMicrosoftShowDeletedCalls(stub func() *ldap.ControlMicrosoftShowDeleted) {
	fake.newControlMicrosoftShowDeletedMutex.Lock()
	defer fake.newControlMicrosoftShowDeletedMutex.Unlock()
	fake.NewControlMicrosoftShowDeletedStub = stub
}

func (fake *FakeV3) NewControlMicrosoftShowDeletedReturns(result1 *ldap.ControlMicrosoftShowDeleted) {
	fake.newControlMicrosoftShowDeletedMutex.Lock()
	defer fake.newControlMicrosoftShowDeletedMutex.Unlock()
	fake.NewControlMicrosoftShowDeletedStub = nil
	fake.newControlMicrosoftShowDeletedReturns = struct {
		result1 *ldap.ControlMicrosoftShowDeleted
	}{result1}
}

func (fake *FakeV3) NewControlMicrosoftShowDeletedReturnsOnCall(i int, result1 *ldap.ControlMicrosoftShowDeleted) {
	fake.newControlMicrosoftShowDeletedMutex.Lock()
	defer fake.newControlMicrosoftShowDeletedMutex.Unlock()
	fake.NewControlMicrosoftShowDeletedStub = nil
	if fake.newControlMicrosoftShowDeletedReturnsOnCall == nil {
		fake.newControlMicrosoftShowDeletedReturnsOnCall = make(map[int]struct {
			result1 *ldap.ControlMicrosoftShowDeleted
		})
	}
	fake.newControlMicrosoftShowDeletedReturnsOnCall[i] = struct {
		result1 *ldap.ControlMicrosoftShowDeleted
	}{result1}
}

func (fake *FakeV3) NewControlPaging(arg1 uint32) *ldap.ControlPaging {
	fake.newControlPagingMutex.Lock()
	ret, specificReturn := fake.newControlPagingReturnsOnCall[len(fake.newControlPagingArgsForCall)]
	fake.newControlPagingArgsForCall = append(fake.newControlPagingArgsForCall, struct {
		arg1 uint32
	}{arg1})
	stub := fake.NewControlPagingStub
	fakeReturns := fake.newControlPagingReturns
	fake.recordInvocation("NewControlPaging", []interface{}{arg1})
	fake.newControlPagingMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeV3) NewControlPagingCallCount() int {
	fake.newControlPagingMutex.RLock()
	defer fake.newControlPagingMutex.RUnlock()
	return len(fake.newControlPagingArgsForCall)
}

func (fake *FakeV3) NewControlPagingCalls(stub func(uint32) *ldap.ControlPaging) {
	fake.newControlPagingMutex.Lock()
	defer fake.newControlPagingMutex.Unlock()
	fake.NewControlPagingStub = stub
}

func (fake *FakeV3) NewControlPagingArgsForCall(i int) uint32 {
	fake.newControlPagingMutex.RLock()
	defer fake.newControlPagingMutex.RUnlock()
	argsForCall := fake.newControlPagingArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeV3) NewControlPagingReturns(result1 *ldap.ControlPaging) {
	fake.newControlPagingMutex.Lock()
	defer fake.newControlPagingMutex.Unlock()
	fake.NewControlPagingStub = nil
	fake.newControlPagingReturns = struct {
		result1 *ldap.ControlPaging
	}{result1}
}

func (fake *FakeV3) NewControlPagingReturnsOnCall(i int, result1 *ldap.ControlPaging) {
	fake.newControlPagingMutex.Lock()
	defer fake.newControlPagingMutex.Unlock()
	fake.NewControlPagingStub = nil
	if fake.newControlPagingReturnsOnCall == nil {
		fake.newControlPagingReturnsOnCall = make(map[int]struct {
			result1 *ldap.ControlPaging
		})
	}
	fake.newControlPagingReturnsOnCall[i] = struct {
		result1 *ldap.ControlPaging
	}{result1}
}

func (fake *FakeV3) NewControlString(arg1 string, arg2 bool, arg3 string) *ldap.ControlString {
	fake.newControlStringMutex.Lock()
	ret, specificReturn := fake.newControlStringReturnsOnCall[len(fake.newControlStringArgsForCall)]
	fake.newControlStringArgsForCall = append(fake.newControlStringArgsForCall, struct {
		arg1 string
		arg2 bool
		arg3 string
	}{arg1, arg2, arg3})
	stub := fake.NewControlStringStub
	fakeReturns := fake.newControlStringReturns
	fake.recordInvocation("NewControlString", []interface{}{arg1, arg2, arg3})
	fake.newControlStringMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeV3) NewControlStringCallCount() int {
	fake.newControlStringMutex.RLock()
	defer fake.newControlStringMutex.RUnlock()
	return len(fake.newControlStringArgsForCall)
}

func (fake *FakeV3) NewControlStringCalls(stub func(string, bool, string) *ldap.ControlString) {
	fake.newControlStringMutex.Lock()
	defer fake.newControlStringMutex.Unlock()
	fake.NewControlStringStub = stub
}

func (fake *FakeV3) NewControlStringArgsForCall(i int) (string, bool, string) {
	fake.newControlStringMutex.RLock()
	defer fake.newControlStringMutex.RUnlock()
	argsForCall := fake.newControlStringArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeV3) NewControlStringReturns(result1 *ldap.ControlString) {
	fake.newControlStringMutex.Lock()
	defer fake.newControlStringMutex.Unlock()
	fake.NewControlStringStub = nil
	fake.newControlStringReturns = struct {
		result1 *ldap.ControlString
	}{result1}
}

func (fake *FakeV3) NewControlStringReturnsOnCall(i int, result1 *ldap.ControlString) {
	fake.newControlStringMutex.Lock()
	defer fake.newControlStringMutex.Unlock()
	fake.NewControlStringStub = nil
	if fake.newControlStringReturnsOnCall == nil {
		fake.newControlStringReturnsOnCall = make(map[int]struct {
			result1 *ldap.ControlString
		})
	}
	fake.newControlStringReturnsOnCall[i] = struct {
		result1 *ldap.ControlString
	}{result1}
}

func (fake *FakeV3) NewControlSubtreeDelete() *ldap.ControlSubtreeDelete {
	fake.newControlSubtreeDeleteMutex.Lock()
	ret, specificReturn := fake.newControlSubtreeDeleteReturnsOnCall[len(fake.newControlSubtreeDeleteArgsForCall)]
	fake.newControlSubtreeDeleteArgsForCall = append(fake.newControlSubtreeDeleteArgsForCall, struct {
	}{})
	stub := fake.NewControlSubtreeDeleteStub
	fakeReturns := fake.newControlSubtreeDeleteReturns
	fake.recordInvocation("NewControlSubtreeDelete", []interface{}{})
	fake.newControlSubtreeDeleteMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeV3) NewControlSubtreeDeleteCallCount() int {
	fake.newControlSubtreeDeleteMutex.RLock()
	defer fake.newControlSubtreeDeleteMutex.RUnlock()
	return len(fake.newControlSubtreeDeleteArgsForCall)
}

func (fake *FakeV3) NewControlSubtreeDeleteCalls(stub func() *ldap.ControlSubtreeDelete) {
	fake.newControlSubtreeDeleteMutex.Lock()
	defer fake.newControlSubtreeDeleteMutex.Unlock()
	fake.NewControlSubtreeDeleteStub = stub
}

func (fake *FakeV3) NewControlSubtreeDeleteReturns(result1 *ldap.ControlSubtreeDelete) {
	fake.newControlSubtreeDeleteMutex.Lock()
	defer fake.newControlSubtreeDeleteMutex.Unlock()
	fake.NewControlSubtreeDeleteStub = nil
	fake.newControlSubtreeDeleteReturns = struct {
		result1 *ldap.ControlSubtreeDelete
	}{result1}
}

func (fake *FakeV3) NewControlSubtreeDeleteReturnsOnCall(i int, result1 *ldap.ControlSubtreeDelete) {
	fake.newControlSubtreeDeleteMutex.Lock()
	defer fake.newControlSubtreeDeleteMutex.Unlock()
	fake.NewControlSubtreeDeleteStub = nil
	if fake.newControlSubtreeDeleteReturnsOnCall == nil {
		fake.newControlSubtreeDeleteReturnsOnCall = make(map[int]struct {
			result1 *ldap.ControlSubtreeDelete
		})
	}
	fake.newControlSubtreeDeleteReturnsOnCall[i] = struct {
		result1 *ldap.ControlSubtreeDelete
	}{result1}
}

func (fake *FakeV3) NewDelRequest(arg1 string, arg2 []ldap.Control) *ldap.DelRequest {
	var arg2Copy []ldap.Control
	if arg2 != nil {
		arg2Copy = make([]ldap.Control, len(arg2))
		copy(arg2Copy, arg2)
	}
	fake.newDelRequestMutex.Lock()
	ret, specificReturn := fake.newDelRequestReturnsOnCall[len(fake.newDelRequestArgsForCall)]
	fake.newDelRequestArgsForCall = append(fake.newDelRequestArgsForCall, struct {
		arg1 string
		arg2 []ldap.Control
	}{arg1, arg2Copy})
	stub := fake.NewDelRequestStub
	fakeReturns := fake.newDelRequestReturns
	fake.recordInvocation("NewDelRequest", []interface{}{arg1, arg2Copy})
	fake.newDelRequestMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeV3) NewDelRequestCallCount() int {
	fake.newDelRequestMutex.RLock()
	defer fake.newDelRequestMutex.RUnlock()
	return len(fake.newDelRequestArgsForCall)
}

func (fake *FakeV3) NewDelRequestCalls(stub func(string, []ldap.Control) *ldap.DelRequest) {
	fake.newDelRequestMutex.Lock()
	defer fake.newDelRequestMutex.Unlock()
	fake.NewDelRequestStub = stub
}

func (fake *FakeV3) NewDelRequestArgsForCall(i int) (string, []ldap.Control) {
	fake.newDelRequestMutex.RLock()
	defer fake.newDelRequestMutex.RUnlock()
	argsForCall := fake.newDelRequestArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeV3) NewDelRequestReturns(result1 *ldap.DelRequest) {
	fake.newDelRequestMutex.Lock()
	defer fake.newDelRequestMutex.Unlock()
	fake.NewDelRequestStub = nil
	fake.newDelRequestReturns = struct {
		result1 *ldap.DelRequest
	}{result1}
}

func (fake *FakeV3) NewDelRequestReturnsOnCall(i int, result1 *ldap.DelRequest) {
	fake.newDelRequestMutex.Lock()
	defer fake.newDelRequestMutex.Unlock()
	fake.NewDelRequestStub = nil
	if fake.newDelRequestReturnsOnCall == nil {
		fake.newDelRequestReturnsOnCall = make(map[int]struct {
			result1 *ldap.DelRequest
		})
	}
	fake.newDelRequestReturnsOnCall[i] = struct {
		result1 *ldap.DelRequest
	}{result1}
}

func (fake *FakeV3) NewEntry(arg1 string, arg2 map[string][]string) *ldap.Entry {
	fake.newEntryMutex.Lock()
	ret, specificReturn := fake.newEntryReturnsOnCall[len(fake.newEntryArgsForCall)]
	fake.newEntryArgsForCall = append(fake.newEntryArgsForCall, struct {
		arg1 string
		arg2 map[string][]string
	}{arg1, arg2})
	stub := fake.NewEntryStub
	fakeReturns := fake.newEntryReturns
	fake.recordInvocation("NewEntry", []interface{}{arg1, arg2})
	fake.newEntryMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeV3) NewEntryCallCount() int {
	fake.newEntryMutex.RLock()
	defer fake.newEntryMutex.RUnlock()
	return len(fake.newEntryArgsForCall)
}

func (fake *FakeV3) NewEntryCalls(stub func(string, map[string][]string) *ldap.Entry) {
	fake.newEntryMutex.Lock()
	defer fake.newEntryMutex.Unlock()
	fake.NewEntryStub = stub
}

func (fake *FakeV3) NewEntryArgsForCall(i int) (string, map[string][]string) {
	fake.newEntryMutex.RLock()
	defer fake.newEntryMutex.RUnlock()
	argsForCall := fake.newEntryArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeV3) NewEntryReturns(result1 *ldap.Entry) {
	fake.newEntryMutex.Lock()
	defer fake.newEntryMutex.Unlock()
	fake.NewEntryStub = nil
	fake.newEntryReturns = struct {
		result1 *ldap.Entry
	}{result1}
}

func (fake *FakeV3) NewEntryReturnsOnCall(i int, result1 *ldap.Entry) {
	fake.newEntryMutex.Lock()
	defer fake.newEntryMutex.Unlock()
	fake.NewEntryStub = nil
	if fake.newEntryReturnsOnCall == nil {
		fake.newEntryReturnsOnCall = make(map[int]struct {
			result1 *ldap.Entry
		})
	}
	fake.newEntryReturnsOnCall[i] = struct {
		result1 *ldap.Entry
	}{result1}
}

func (fake *FakeV3) NewEntryAttribute(arg1 string, arg2 []string) *ldap.EntryAttribute {
	var arg2Copy []string
	if arg2 != nil {
		arg2Copy = make([]string, len(arg2))
		copy(arg2Copy, arg2)
	}
	fake.newEntryAttributeMutex.Lock()
	ret, specificReturn := fake.newEntryAttributeReturnsOnCall[len(fake.newEntryAttributeArgsForCall)]
	fake.newEntryAttributeArgsForCall = append(fake.newEntryAttributeArgsForCall, struct {
		arg1 string
		arg2 []string
	}{arg1, arg2Copy})
	stub := fake.NewEntryAttributeStub
	fakeReturns := fake.newEntryAttributeReturns
	fake.recordInvocation("NewEntryAttribute", []interface{}{arg1, arg2Copy})
	fake.newEntryAttributeMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeV3) NewEntryAttributeCallCount() int {
	fake.newEntryAttributeMutex.RLock()
	defer fake.newEntryAttributeMutex.RUnlock()
	return len(fake.newEntryAttributeArgsForCall)
}

func (fake *FakeV3) NewEntryAttributeCalls(stub func(string, []string) *ldap.EntryAttribute) {
	fake.newEntryAttributeMutex.Lock()
	defer fake.newEntryAttributeMutex.Unlock()
	fake.NewEntryAttributeStub = stub
}

func (fake *FakeV3) NewEntryAttributeArgsForCall(i int) (string, []string) {
	fake.newEntryAttributeMutex.RLock()
	defer fake.newEntryAttributeMutex.RUnlock()
	argsForCall := fake.newEntryAttributeArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeV3) NewEntryAttributeReturns(result1 *ldap.EntryAttribute) {
	fake.newEntryAttributeMutex.Lock()
	defer fake.newEntryAttributeMutex.Unlock()
	fake.NewEntryAttributeStub = nil
	fake.newEntryAttributeReturns = struct {
		result1 *ldap.EntryAttribute
	}{result1}
}

func (fake *FakeV3) NewEntryAttributeReturnsOnCall(i int, result1 *ldap.EntryAttribute) {
	fake.newEntryAttributeMutex.Lock()
	defer fake.newEntryAttributeMutex.Unlock()
	fake.NewEntryAttributeStub = nil
	if fake.newEntryAttributeReturnsOnCall == nil {
		fake.newEntryAttributeReturnsOnCall = make(map[int]struct {
			result1 *ldap.EntryAttribute
		})
	}
	fake.newEntryAttributeReturnsOnCall[i] = struct {
		result1 *ldap.EntryAttribute
	}{result1}
}

func (fake *FakeV3) NewError(arg1 uint16, arg2 error) error {
	fake.newErrorMutex.Lock()
	ret, specificReturn := fake.newErrorReturnsOnCall[len(fake.newErrorArgsForCall)]
	fake.newErrorArgsForCall = append(fake.newErrorArgsForCall, struct {
		arg1 uint16
		arg2 error
	}{arg1, arg2})
	stub := fake.NewErrorStub
	fakeReturns := fake.newErrorReturns
	fake.recordInvocation("NewError", []interface{}{arg1, arg2})
	fake.newErrorMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeV3) NewErrorCallCount() int {
	fake.newErrorMutex.RLock()
	defer fake.newErrorMutex.RUnlock()
	return len(fake.newErrorArgsForCall)
}

func (fake *FakeV3) NewErrorCalls(stub func(uint16, error) error) {
	fake.newErrorMutex.Lock()
	defer fake.newErrorMutex.Unlock()
	fake.NewErrorStub = stub
}

func (fake *FakeV3) NewErrorArgsForCall(i int) (uint16, error) {
	fake.newErrorMutex.RLock()
	defer fake.newErrorMutex.RUnlock()
	argsForCall := fake.newErrorArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeV3) NewErrorReturns(result1 error) {
	fake.newErrorMutex.Lock()
	defer fake.newErrorMutex.Unlock()
	fake.NewErrorStub = nil
	fake.newErrorReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeV3) NewErrorReturnsOnCall(i int, result1 error) {
	fake.newErrorMutex.Lock()
	defer fake.newErrorMutex.Unlock()
	fake.NewErrorStub = nil
	if fake.newErrorReturnsOnCall == nil {
		fake.newErrorReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.newErrorReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeV3) NewModifyDNRequest(arg1 string, arg2 string, arg3 bool, arg4 string) *ldap.ModifyDNRequest {
	fake.newModifyDNRequestMutex.Lock()
	ret, specificReturn := fake.newModifyDNRequestReturnsOnCall[len(fake.newModifyDNRequestArgsForCall)]
	fake.newModifyDNRequestArgsForCall = append(fake.newModifyDNRequestArgsForCall, struct {
		arg1 string
		arg2 string
		arg3 bool
		arg4 string
	}{arg1, arg2, arg3, arg4})
	stub := fake.NewModifyDNRequestStub
	fakeReturns := fake.newModifyDNRequestReturns
	fake.recordInvocation("NewModifyDNRequest", []interface{}{arg1, arg2, arg3, arg4})
	fake.newModifyDNRequestMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeV3) NewModifyDNRequestCallCount() int {
	fake.newModifyDNRequestMutex.RLock()
	defer fake.newModifyDNRequestMutex.RUnlock()
	return len(fake.newModifyDNRequestArgsForCall)
}

func (fake *FakeV3) NewModifyDNRequestCalls(stub func(string, string, bool, string) *ldap.ModifyDNRequest) {
	fake.newModifyDNRequestMutex.Lock()
	defer fake.newModifyDNRequestMutex.Unlock()
	fake.NewModifyDNRequestStub = stub
}

func (fake *FakeV3) NewModifyDNRequestArgsForCall(i int) (string, string, bool, string) {
	fake.newModifyDNRequestMutex.RLock()
	defer fake.newModifyDNRequestMutex.RUnlock()
	argsForCall := fake.newModifyDNRequestArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeV3) NewModifyDNRequestReturns(result1 *ldap.ModifyDNRequest) {
	fake.newModifyDNRequestMutex.Lock()
	defer fake.newModifyDNRequestMutex.Unlock()
	fake.NewModifyDNRequestStub = nil
	fake.newModifyDNRequestReturns = struct {
		result1 *ldap.ModifyDNRequest
	}{result1}
}

func (fake *FakeV3) NewModifyDNRequestReturnsOnCall(i int, result1 *ldap.ModifyDNRequest) {
	fake.newModifyDNRequestMutex.Lock()
	defer fake.newModifyDNRequestMutex.Unlock()
	fake.NewModifyDNRequestStub = nil
	if fake.newModifyDNRequestReturnsOnCall == nil {
		fake.newModifyDNRequestReturnsOnCall = make(map[int]struct {
			result1 *ldap.ModifyDNRequest
		})
	}
	fake.newModifyDNRequestReturnsOnCall[i] = struct {
		result1 *ldap.ModifyDNRequest
	}{result1}
}

func (fake *FakeV3) NewModifyDNWithControlsRequest(arg1 string, arg2 string, arg3 bool, arg4 string, arg5 []ldap.Control) *ldap.ModifyDNRequest {
	var arg5Copy []ldap.Control
	if arg5 != nil {
		arg5Copy = make([]ldap.Control, len(arg5))
		copy(arg5Copy, arg5)
	}
	fake.newModifyDNWithControlsRequestMutex.Lock()
	ret, specificReturn := fake.newModifyDNWithControlsRequestReturnsOnCall[len(fake.newModifyDNWithControlsRequestArgsForCall)]
	fake.newModifyDNWithControlsRequestArgsForCall = append(fake.newModifyDNWithControlsRequestArgsForCall, struct {
		arg1 string
		arg2 string
		arg3 bool
		arg4 string
		arg5 []ldap.Control
	}{arg1, arg2, arg3, arg4, arg5Copy})
	stub := fake.NewModifyDNWithControlsRequestStub
	fakeReturns := fake.newModifyDNWithControlsRequestReturns
	fake.recordInvocation("NewModifyDNWithControlsRequest", []interface{}{arg1, arg2, arg3, arg4, arg5Copy})
	fake.newModifyDNWithControlsRequestMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4, arg5)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeV3) NewModifyDNWithControlsRequestCallCount() int {
	fake.newModifyDNWithControlsRequestMutex.RLock()
	defer fake.newModifyDNWithControlsRequestMutex.RUnlock()
	return len(fake.newModifyDNWithControlsRequestArgsForCall)
}

func (fake *FakeV3) NewModifyDNWithControlsRequestCalls(stub func(string, string, bool, string, []ldap.Control) *ldap.ModifyDNRequest) {
	fake.newModifyDNWithControlsRequestMutex.Lock()
	defer fake.newModifyDNWithControlsRequestMutex.Unlock()
	fake.NewModifyDNWithControlsRequestStub = stub
}

func (fake *FakeV3) NewModifyDNWithControlsRequestArgsForCall(i int) (string, string, bool, string, []ldap.Control) {
	fake.newModifyDNWithControlsRequestMutex.RLock()
	defer fake.newModifyDNWithControlsRequestMutex.RUnlock()
	argsForCall := fake.newModifyDNWithControlsRequestArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4, argsForCall.arg5
}

func (fake *FakeV3) NewModifyDNWithControlsRequestReturns(result1 *ldap.ModifyDNRequest) {
	fake.newModifyDNWithControlsRequestMutex.Lock()
	defer fake.newModifyDNWithControlsRequestMutex.Unlock()
	fake.NewModifyDNWithControlsRequestStub = nil
	fake.newModifyDNWithControlsRequestReturns = struct {
		result1 *ldap.ModifyDNRequest
	}{result1}
}

func (fake *FakeV3) NewModifyDNWithControlsRequestReturnsOnCall(i int, result1 *ldap.ModifyDNRequest) {
	fake.newModifyDNWithControlsRequestMutex.Lock()
	defer fake.newModifyDNWithControlsRequestMutex.Unlock()
	fake.NewModifyDNWithControlsRequestStub = nil
	if fake.newModifyDNWithControlsRequestReturnsOnCall == nil {
		fake.newModifyDNWithControlsRequestReturnsOnCall = make(map[int]struct {
			result1 *ldap.ModifyDNRequest
		})
	}
	fake.newModifyDNWithControlsRequestReturnsOnCall[i] = struct {
		result1 *ldap.ModifyDNRequest
	}{result1}
}

func (fake *FakeV3) NewModifyRequest(arg1 string, arg2 []ldap.Control) *ldap.ModifyRequest {
	var arg2Copy []ldap.Control
	if arg2 != nil {
		arg2Copy = make([]ldap.Control, len(arg2))
		copy(arg2Copy, arg2)
	}
	fake.newModifyRequestMutex.Lock()
	ret, specificReturn := fake.newModifyRequestReturnsOnCall[len(fake.newModifyRequestArgsForCall)]
	fake.newModifyRequestArgsForCall = append(fake.newModifyRequestArgsForCall, struct {
		arg1 string
		arg2 []ldap.Control
	}{arg1, arg2Copy})
	stub := fake.NewModifyRequestStub
	fakeReturns := fake.newModifyRequestReturns
	fake.recordInvocation("NewModifyRequest", []interface{}{arg1, arg2Copy})
	fake.newModifyRequestMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeV3) NewModifyRequestCallCount() int {
	fake.newModifyRequestMutex.RLock()
	defer fake.newModifyRequestMutex.RUnlock()
	return len(fake.newModifyRequestArgsForCall)
}

func (fake *FakeV3) NewModifyRequestCalls(stub func(string, []ldap.Control) *ldap.ModifyRequest) {
	fake.newModifyRequestMutex.Lock()
	defer fake.newModifyRequestMutex.Unlock()
	fake.NewModifyRequestStub = stub
}

func (fake *FakeV3) NewModifyRequestArgsForCall(i int) (string, []ldap.Control) {
	fake.newModifyRequestMutex.RLock()
	defer fake.newModifyRequestMutex.RUnlock()
	argsForCall := fake.newModifyRequestArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeV3) NewModifyRequestReturns(result1 *ldap.ModifyRequest) {
	fake.newModifyRequestMutex.Lock()
	defer fake.newModifyRequestMutex.Unlock()
	fake.NewModifyRequestStub = nil
	fake.newModifyRequestReturns = struct {
		result1 *ldap.ModifyRequest
	}{result1}
}

func (fake *FakeV3) NewModifyRequestReturnsOnCall(i int, result1 *ldap.ModifyRequest) {
	fake.newModifyRequestMutex.Lock()
	defer fake.newModifyRequestMutex.Unlock()
	fake.NewModifyRequestStub = nil
	if fake.newModifyRequestReturnsOnCall == nil {
		fake.newModifyRequestReturnsOnCall = make(map[int]struct {
			result1 *ldap.ModifyRequest
		})
	}
	fake.newModifyRequestReturnsOnCall[i] = struct {
		result1 *ldap.ModifyRequest
	}{result1}
}

func (fake *FakeV3) NewPasswordModifyRequest(arg1 string, arg2 string, arg3 string) *ldap.PasswordModifyRequest {
	fake.newPasswordModifyRequestMutex.Lock()
	ret, specificReturn := fake.newPasswordModifyRequestReturnsOnCall[len(fake.newPasswordModifyRequestArgsForCall)]
	fake.newPasswordModifyRequestArgsForCall = append(fake.newPasswordModifyRequestArgsForCall, struct {
		arg1 string
		arg2 string
		arg3 string
	}{arg1, arg2, arg3})
	stub := fake.NewPasswordModifyRequestStub
	fakeReturns := fake.newPasswordModifyRequestReturns
	fake.recordInvocation("NewPasswordModifyRequest", []interface{}{arg1, arg2, arg3})
	fake.newPasswordModifyRequestMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeV3) NewPasswordModifyRequestCallCount() int {
	fake.newPasswordModifyRequestMutex.RLock()
	defer fake.newPasswordModifyRequestMutex.RUnlock()
	return len(fake.newPasswordModifyRequestArgsForCall)
}

func (fake *FakeV3) NewPasswordModifyRequestCalls(stub func(string, string, string) *ldap.PasswordModifyRequest) {
	fake.newPasswordModifyRequestMutex.Lock()
	defer fake.newPasswordModifyRequestMutex.Unlock()
	fake.NewPasswordModifyRequestStub = stub
}

func (fake *FakeV3) NewPasswordModifyRequestArgsForCall(i int) (string, string, string) {
	fake.newPasswordModifyRequestMutex.RLock()
	defer fake.newPasswordModifyRequestMutex.RUnlock()
	argsForCall := fake.newPasswordModifyRequestArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeV3) NewPasswordModifyRequestReturns(result1 *ldap.PasswordModifyRequest) {
	fake.newPasswordModifyRequestMutex.Lock()
	defer fake.newPasswordModifyRequestMutex.Unlock()
	fake.NewPasswordModifyRequestStub = nil
	fake.newPasswordModifyRequestReturns = struct {
		result1 *ldap.PasswordModifyRequest
	}{result1}
}

func (fake *FakeV3) NewPasswordModifyRequestReturnsOnCall(i int, result1 *ldap.PasswordModifyRequest) {
	fake.newPasswordModifyRequestMutex.Lock()
	defer fake.newPasswordModifyRequestMutex.Unlock()
	fake.NewPasswordModifyRequestStub = nil
	if fake.newPasswordModifyRequestReturnsOnCall == nil {
		fake.newPasswordModifyRequestReturnsOnCall = make(map[int]struct {
			result1 *ldap.PasswordModifyRequest
		})
	}
	fake.newPasswordModifyRequestReturnsOnCall[i] = struct {
		result1 *ldap.PasswordModifyRequest
	}{result1}
}

func (fake *FakeV3) NewSearchRequest(arg1 string, arg2 int, arg3 int, arg4 int, arg5 int, arg6 bool, arg7 string, arg8 []string, arg9 []ldap.Control) *ldap.SearchRequest {
	var arg8Copy []string
	if arg8 != nil {
		arg8Copy = make([]string, len(arg8))
		copy(arg8Copy, arg8)
	}
	var arg9Copy []ldap.Control
	if arg9 != nil {
		arg9Copy = make([]ldap.Control, len(arg9))
		copy(arg9Copy, arg9)
	}
	fake.newSearchRequestMutex.Lock()
	ret, specificReturn := fake.newSearchRequestReturnsOnCall[len(fake.newSearchRequestArgsForCall)]
	fake.newSearchRequestArgsForCall = append(fake.newSearchRequestArgsForCall, struct {
		arg1 string
		arg2 int
		arg3 int
		arg4 int
		arg5 int
		arg6 bool
		arg7 string
		arg8 []string
		arg9 []ldap.Control
	}{arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8Copy, arg9Copy})
	stub := fake.NewSearchRequestStub
	fakeReturns := fake.newSearchRequestReturns
	fake.recordInvocation("NewSearchRequest", []interface{}{arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8Copy, arg9Copy})
	fake.newSearchRequestMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeV3) NewSearchRequestCallCount() int {
	fake.newSearchRequestMutex.RLock()
	defer fake.newSearchRequestMutex.RUnlock()
	return len(fake.newSearchRequestArgsForCall)
}

func (fake *FakeV3) NewSearchRequestCalls(stub func(string, int, int, int, int, bool, string, []string, []ldap.Control) *ldap.SearchRequest) {
	fake.newSearchRequestMutex.Lock()
	defer fake.newSearchRequestMutex.Unlock()
	fake.NewSearchRequestStub = stub
}

func (fake *FakeV3) NewSearchRequestArgsForCall(i int) (string, int, int, int, int, bool, string, []string, []ldap.Control) {
	fake.newSearchRequestMutex.RLock()
	defer fake.newSearchRequestMutex.RUnlock()
	argsForCall := fake.newSearchRequestArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4, argsForCall.arg5, argsForCall.arg6, argsForCall.arg7, argsForCall.arg8, argsForCall.arg9
}

func (fake *FakeV3) NewSearchRequestReturns(result1 *ldap.SearchRequest) {
	fake.newSearchRequestMutex.Lock()
	defer fake.newSearchRequestMutex.Unlock()
	fake.NewSearchRequestStub = nil
	fake.newSearchRequestReturns = struct {
		result1 *ldap.SearchRequest
	}{result1}
}

func (fake *FakeV3) NewSearchRequestReturnsOnCall(i int, result1 *ldap.SearchRequest) {
	fake.newSearchRequestMutex.Lock()
	defer fake.newSearchRequestMutex.Unlock()
	fake.NewSearchRequestStub = nil
	if fake.newSearchRequestReturnsOnCall == nil {
		fake.newSearchRequestReturnsOnCall = make(map[int]struct {
			result1 *ldap.SearchRequest
		})
	}
	fake.newSearchRequestReturnsOnCall[i] = struct {
		result1 *ldap.SearchRequest
	}{result1}
}

func (fake *FakeV3) NewSimpleBindRequest(arg1 string, arg2 string, arg3 []ldap.Control) *ldap.SimpleBindRequest {
	var arg3Copy []ldap.Control
	if arg3 != nil {
		arg3Copy = make([]ldap.Control, len(arg3))
		copy(arg3Copy, arg3)
	}
	fake.newSimpleBindRequestMutex.Lock()
	ret, specificReturn := fake.newSimpleBindRequestReturnsOnCall[len(fake.newSimpleBindRequestArgsForCall)]
	fake.newSimpleBindRequestArgsForCall = append(fake.newSimpleBindRequestArgsForCall, struct {
		arg1 string
		arg2 string
		arg3 []ldap.Control
	}{arg1, arg2, arg3Copy})
	stub := fake.NewSimpleBindRequestStub
	fakeReturns := fake.newSimpleBindRequestReturns
	fake.recordInvocation("NewSimpleBindRequest", []interface{}{arg1, arg2, arg3Copy})
	fake.newSimpleBindRequestMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeV3) NewSimpleBindRequestCallCount() int {
	fake.newSimpleBindRequestMutex.RLock()
	defer fake.newSimpleBindRequestMutex.RUnlock()
	return len(fake.newSimpleBindRequestArgsForCall)
}

func (fake *FakeV3) NewSimpleBindRequestCalls(stub func(string, string, []ldap.Control) *ldap.SimpleBindRequest) {
	fake.newSimpleBindRequestMutex.Lock()
	defer fake.newSimpleBindRequestMutex.Unlock()
	fake.NewSimpleBindRequestStub = stub
}

func (fake *FakeV3) NewSimpleBindRequestArgsForCall(i int) (string, string, []ldap.Control) {
	fake.newSimpleBindRequestMutex.RLock()
	defer fake.newSimpleBindRequestMutex.RUnlock()
	argsForCall := fake.newSimpleBindRequestArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeV3) NewSimpleBindRequestReturns(result1 *ldap.SimpleBindRequest) {
	fake.newSimpleBindRequestMutex.Lock()
	defer fake.newSimpleBindRequestMutex.Unlock()
	fake.NewSimpleBindRequestStub = nil
	fake.newSimpleBindRequestReturns = struct {
		result1 *ldap.SimpleBindRequest
	}{result1}
}

func (fake *FakeV3) NewSimpleBindRequestReturnsOnCall(i int, result1 *ldap.SimpleBindRequest) {
	fake.newSimpleBindRequestMutex.Lock()
	defer fake.newSimpleBindRequestMutex.Unlock()
	fake.NewSimpleBindRequestStub = nil
	if fake.newSimpleBindRequestReturnsOnCall == nil {
		fake.newSimpleBindRequestReturnsOnCall = make(map[int]struct {
			result1 *ldap.SimpleBindRequest
		})
	}
	fake.newSimpleBindRequestReturnsOnCall[i] = struct {
		result1 *ldap.SimpleBindRequest
	}{result1}
}

func (fake *FakeV3) ParseDN(arg1 string) (*ldap.DN, error) {
	fake.parseDNMutex.Lock()
	ret, specificReturn := fake.parseDNReturnsOnCall[len(fake.parseDNArgsForCall)]
	fake.parseDNArgsForCall = append(fake.parseDNArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.ParseDNStub
	fakeReturns := fake.parseDNReturns
	fake.recordInvocation("ParseDN", []interface{}{arg1})
	fake.parseDNMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeV3) ParseDNCallCount() int {
	fake.parseDNMutex.RLock()
	defer fake.parseDNMutex.RUnlock()
	return len(fake.parseDNArgsForCall)
}

func (fake *FakeV3) ParseDNCalls(stub func(string) (*ldap.DN, error)) {
	fake.parseDNMutex.Lock()
	defer fake.parseDNMutex.Unlock()
	fake.ParseDNStub = stub
}

func (fake *FakeV3) ParseDNArgsForCall(i int) string {
	fake.parseDNMutex.RLock()
	defer fake.parseDNMutex.RUnlock()
	argsForCall := fake.parseDNArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeV3) ParseDNReturns(result1 *ldap.DN, result2 error) {
	fake.parseDNMutex.Lock()
	defer fake.parseDNMutex.Unlock()
	fake.ParseDNStub = nil
	fake.parseDNReturns = struct {
		result1 *ldap.DN
		result2 error
	}{result1, result2}
}

func (fake *FakeV3) ParseDNReturnsOnCall(i int, result1 *ldap.DN, result2 error) {
	fake.parseDNMutex.Lock()
	defer fake.parseDNMutex.Unlock()
	fake.ParseDNStub = nil
	if fake.parseDNReturnsOnCall == nil {
		fake.parseDNReturnsOnCall = make(map[int]struct {
			result1 *ldap.DN
			result2 error
		})
	}
	fake.parseDNReturnsOnCall[i] = struct {
		result1 *ldap.DN
		result2 error
	}{result1, result2}
}

func (fake *FakeV3) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.compileFilterMutex.RLock()
	defer fake.compileFilterMutex.RUnlock()
	fake.debugBinaryFileMutex.RLock()
	defer fake.debugBinaryFileMutex.RUnlock()
	fake.decodeControlMutex.RLock()
	defer fake.decodeControlMutex.RUnlock()
	fake.decompileFilterMutex.RLock()
	defer fake.decompileFilterMutex.RUnlock()
	fake.dialMutex.RLock()
	defer fake.dialMutex.RUnlock()
	fake.dialTLSMutex.RLock()
	defer fake.dialTLSMutex.RUnlock()
	fake.dialURLMutex.RLock()
	defer fake.dialURLMutex.RUnlock()
	fake.dialWithDialerMutex.RLock()
	defer fake.dialWithDialerMutex.RUnlock()
	fake.dialWithTLSConfigMutex.RLock()
	defer fake.dialWithTLSConfigMutex.RUnlock()
	fake.dialWithTLSDialerMutex.RLock()
	defer fake.dialWithTLSDialerMutex.RUnlock()
	fake.escapeFilterMutex.RLock()
	defer fake.escapeFilterMutex.RUnlock()
	fake.findControlMutex.RLock()
	defer fake.findControlMutex.RUnlock()
	fake.getLDAPErrorMutex.RLock()
	defer fake.getLDAPErrorMutex.RUnlock()
	fake.isErrorAnyOfMutex.RLock()
	defer fake.isErrorAnyOfMutex.RUnlock()
	fake.isErrorWithCodeMutex.RLock()
	defer fake.isErrorWithCodeMutex.RUnlock()
	fake.loggerMutex.RLock()
	defer fake.loggerMutex.RUnlock()
	fake.newAddRequestMutex.RLock()
	defer fake.newAddRequestMutex.RUnlock()
	fake.newConnMutex.RLock()
	defer fake.newConnMutex.RUnlock()
	fake.newControlBeheraPasswordPolicyMutex.RLock()
	defer fake.newControlBeheraPasswordPolicyMutex.RUnlock()
	fake.newControlManageDsaITMutex.RLock()
	defer fake.newControlManageDsaITMutex.RUnlock()
	fake.newControlMicrosoftNotificationMutex.RLock()
	defer fake.newControlMicrosoftNotificationMutex.RUnlock()
	fake.newControlMicrosoftServerLinkTTLMutex.RLock()
	defer fake.newControlMicrosoftServerLinkTTLMutex.RUnlock()
	fake.newControlMicrosoftShowDeletedMutex.RLock()
	defer fake.newControlMicrosoftShowDeletedMutex.RUnlock()
	fake.newControlPagingMutex.RLock()
	defer fake.newControlPagingMutex.RUnlock()
	fake.newControlStringMutex.RLock()
	defer fake.newControlStringMutex.RUnlock()
	fake.newControlSubtreeDeleteMutex.RLock()
	defer fake.newControlSubtreeDeleteMutex.RUnlock()
	fake.newDelRequestMutex.RLock()
	defer fake.newDelRequestMutex.RUnlock()
	fake.newEntryMutex.RLock()
	defer fake.newEntryMutex.RUnlock()
	fake.newEntryAttributeMutex.RLock()
	defer fake.newEntryAttributeMutex.RUnlock()
	fake.newErrorMutex.RLock()
	defer fake.newErrorMutex.RUnlock()
	fake.newModifyDNRequestMutex.RLock()
	defer fake.newModifyDNRequestMutex.RUnlock()
	fake.newModifyDNWithControlsRequestMutex.RLock()
	defer fake.newModifyDNWithControlsRequestMutex.RUnlock()
	fake.newModifyRequestMutex.RLock()
	defer fake.newModifyRequestMutex.RUnlock()
	fake.newPasswordModifyRequestMutex.RLock()
	defer fake.newPasswordModifyRequestMutex.RUnlock()
	fake.newSearchRequestMutex.RLock()
	defer fake.newSearchRequestMutex.RUnlock()
	fake.newSimpleBindRequestMutex.RLock()
	defer fake.newSimpleBindRequestMutex.RUnlock()
	fake.parseDNMutex.RLock()
	defer fake.parseDNMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeV3) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ v3shim.V3 = new(FakeV3)
